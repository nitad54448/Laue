<!DOCTYPE html>
<html>
<head>
    <title>Laue Diagram Simulator</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        body { margin: 0; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif; overflow: hidden; display: flex; height: 100vh; }
        #appContainer { display: flex; flex-direction: row; width: 100%; height: 100%; }
        #controlsPanel {
            width: 350px;
            flex-shrink: 0;
            padding: 10px;
            background-color: #f7f7ff;
            overflow-y: auto;
            height: 100%;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
        }
        #resizer {
            width: 5px;
            cursor: col-resize;
            background-color: #e0e0e0;
            flex-shrink: 0;
            border-left: 1px solid #ccc;
            border-right: 1px solid #ccc;
        }
        #controlsContent {
            flex-grow: 1;
            overflow-y: auto;
            padding-right: 10px;
        }
        #mainView {
            flex-grow: 1;
            display: flex;
            flex-direction: row;
            width: 100%;
        }
        #visualizationContainer { display: none; }
        #detectorContainer {
            width: 100%;
            height: 100%;
            position: relative;
            border-left: none;
            box-sizing: border-box;
            cursor: default;
        }
        #detectorCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #1a1a2a;
        }
        label, input, select, button { font-size: 0.9em; }
        input[type=number] { width: 100%; padding: 6px; box-sizing: border-box; border: 1px solid #ccc; border-radius: 4px; text-align: center;}
        input[type=radio] { vertical-align: middle; }
        input[type=range] { width: 100%; vertical-align: middle; }
        select { padding: 6px; width: 100%; border: 1px solid #ccc; border-radius: 4px; background-color: white;}
        button { background-color: #e7e7e7; border: 1px solid #ccc; border-radius: 4px; cursor: pointer; }
        button:hover { background-color: #d7d7d7; }
        .info-section { margin-bottom: 12px; padding: 12px; border: 1px solid #e0e0e0; border-radius: 6px; background-color: #fff; box-shadow: 0 1px 3px rgba(0,0,0,0.05);}
        .block-label {display: block; margin-bottom: 10px; font-weight: 600; color: #333;}
        .grid-container { display: grid; grid-template-columns: 1fr 1fr; gap: 10px 15px; align-items: center; }
        .grid-span-2 { grid-column: span 2; }
        .grid-container label { text-align: left; font-weight: 500;}
        .grid-container span { text-align: right; font-weight: 500; color: #333; padding-right: 5px;}
        #hklInfo { font-size: 0.9em; line-height: 1.5; font-weight:bold; margin-top:10px; height:auto; min-height:40px; background-color: #e8f0fe; padding: 8px; border-radius: 4px; border: 1px solid #cce;}
        .footer-attribution { margin-top: auto; padding-top: 10px; font-size: 0.8em; text-align: center; color: #aaa; }
    </style>
</head>
<body>
    <div id="appContainer">
        <div id="controlsPanel">
            <div id="controlsContent">
                
                <div class="info-section grid-container">
                    <label for="crystalSystem" class="grid-span-2">Crystal System</label>
                    <select id="crystalSystem" class="grid-span-2">
                        <option value="cubic" selected>Cubic</option>
                        <option value="tetragonal">Tetragonal</option>
                        <option value="orthorhombic">Orthorhombic</option>
                        <option value="hexagonal">Hexagonal</option>
                        <option value="trigonal">Trigonal</option>
                        <option value="monoclinic">Monoclinic</option>
                        <option value="triclinic">Triclinic</option>
                    </select>
                    <label for="bravaisLattice" class="grid-span-2">Bravais Lattice</label>
                    <select id="bravaisLattice" class="grid-span-2"></select>
                </div>

                <div class="info-section">
                    <span class="block-label">Lattice Parameters</span>
                    <div id="latticeParamsContainer" class="grid-container">
                        <div id="row_a" class="grid-span-2" style="display: contents;"> <label for="a">a (Å)</label> <input type="number" id="a" value="6.0" step="0.1" min="1"> </div>
                        <div id="row_b" class="grid-span-2" style="display: contents;"> <label for="b">b (Å)</label> <input type="number" id="b" value="7.0" step="0.1" min="1"> </div>
                        <div id="row_c" class="grid-span-2" style="display: contents;"> <label for="c">c (Å)</label> <input type="number" id="c" value="8.0" step="0.1" min="1"> </div>
                        <div id="row_alpha" class="grid-span-2" style="display: contents;"> <label for="alpha">α (°)</label> <input type="number" id="alpha" value="90.0" step="0.1"> </div>
                        <div id="row_beta" class="grid-span-2" style="display: contents;"> <label for="beta">β (°)</label> <input type="number" id="beta" value="90.0" step="0.1"> </div>
                        <div id="row_gamma" class="grid-span-2" style="display: contents;"> <label for="gamma">γ (°)</label> <input type="number" id="gamma" value="90.0" step="0.1"> </div>
                    </div>
                </div>
                                
                <div class="info-section" id="hklInfo">Spots outside the detector area (dashed circle) are shown faded.</div>

                <div id="singleCrystalControls">
                    <div id="rotationControls" class="info-section">
                        <span class="block-label">Crystal Rotation (°)</span>
                         <div class="grid-container" style="grid-template-columns: auto 1fr 60px;">
                            <label for="rotX">X:</label>
                            <input type="range" id="rotX_slider" value="0" min="-90" max="90" step="1">
                            <input type="number" id="rotX" value="0" min="-90" max="90" step="1">
                            
                            <label for="rotY">Y:</label>
                            <input type="range" id="rotY_slider" value="0" min="-90" max="90" step="1">
                            <input type="number" id="rotY" value="0" min="-90" max="90" step="1">

                            <label for="rotZ">Z:</label>
                            <input type="range" id="rotZ_slider" value="0" min="-90" max="90" step="1">
                            <input type="number" id="rotZ" value="0" min="-90" max="90" step="1">
                        </div>
                    </div>
                </div>
                
                <div class="info-section">
                    <span class="block-label">X-Ray Source (Laue)</span>
                    <div id="lambdaControls" class="grid-container" style="grid-template-columns: auto 1fr 65px;">
                        <label for="lambda_min">λ_min (Å)</label>
                        <input type="range" id="lambda_min_slider" value="0.2" min="0.1" max="2.0" step="0.1">
                        <input type="number" id="lambda_min" value="0.2" min="0.1" max="2.0" step="0.1">
                        
                        <label for="lambda_max">λ_max (Å)</label>
                        <input type="range" id="lambda_max_slider" value="2.0" min="0.2" max="5.0" step="0.1">
                        <input type="number" id="lambda_max" value="2.0" min="0.2" max="5.0" step="0.1">
                    </div>
                </div>

                <div class="info-section">
                    <span class="block-label">Detector Geometry</span>
                    <div class="grid-container">
                        <label for="detectorPosition">Position</label>
                        <select id="detectorPosition" class="grid-span-2">
                            <option value="back" selected>Back-scattering</option>
                            <option value="transmission">Transmission</option>
                        </select>
                        <label for="detectorDistance" class="grid-span-2">Distance (mm)</label>
                        <div class="grid-span-2" style="display: grid; grid-template-columns: 1fr 65px; gap: 10px; align-items: center;">
                           <input type="range" id="detectorDistance_slider" value="50" min="5" max="200" step="1">
                           <input type="number" id="detectorDistance" value="50" min="5" max="200" step="1">
                        </div>
                        
                        <label for="detectorDiameter" class="grid-span-2" style="margin-top: 10px;">Diameter (mm)</label>
                        <div class="grid-span-2" style="display: grid; grid-template-columns: 1fr 65px; gap: 10px; align-items: center;">
                           <input type="range" id="detectorDiameter_slider" value="150" min="50" max="250" step="10">
                           <input type="number" id="detectorDiameter" value="150" min="50" max="250" step="10">
                        </div>
                    </div>
                </div>

                <div class="info-section">
                    <span class="block-label">Range (h, k, l)</span>
                     <div class="grid-container" style="grid-template-columns: auto 1fr 1fr;">
                        <label for="h_min">h</label> <input type="number" id="h_min" value="-10" step="1"> <input type="number" id="h_max" value="10" step="1">
                        <label for="k_min">k</label> <input type="number" id="k_min" value="-10" step="1"> <input type="number" id="k_max" value="10" step="1">
                        <label for="l_min">l</label> <input type="number" id="l_min" value="-10" step="1"> <input type="number" id="l_max" value="10" step="1">
                    </div>
                </div>

            </div>
            <div class="footer-attribution">
                NitaD, Univ Paris-Saclay, 2 Juin 2025
            </div>
        </div>
        <div id="resizer"></div>
        <div id="mainView">
            <div id="visualizationContainer"></div>
            <div id="detectorContainer">
                <canvas id="detectorCanvas"></canvas>
            </div>
        </div>
    </div>
        
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
<script>
        // --- Global Variables ---
        const mainGroup = new THREE.Group();
        let reciprocalMatrix = new THREE.Matrix3();
        let hklInfoDiv;
        
        // --- Detector Variables ---
        let detectorCanvas, detectorCtx, detectorContainer;
        let detectorSpots = [];
        let isPanning = false; // This variable will now mean "is rotating"
        let isDragging = false;
        let mouseDownPosition = new THREE.Vector2(0, 0);
        let lastTouchDistance = 0;
        let lastTouchCenter = null;
        let highlightedSpot = null;

        const bravaisOptions = { 'triclinic':['P'], 'monoclinic':['P','C'], 'orthorhombic':['P','C','I','F'], 'tetragonal':['P','I'], 'trigonal':['R'], 'hexagonal':['P'], 'cubic':['P','I','F'] };

        function init() {
            hklInfoDiv = document.getElementById('hklInfo');
            detectorContainer = document.getElementById('detectorContainer');
            detectorCanvas = document.getElementById('detectorCanvas');
            detectorCtx = detectorCanvas.getContext('2d');
            
            setupEventListeners();
            initResizer();
            handleCrystalSystemChange(); 
            onWindowResize();
            requestAnimationFrame(animate); 
        }

        function initResizer() {
            const resizer = document.getElementById('resizer');
            const panel = document.getElementById('controlsPanel');
            let startX, startWidth;
            resizer.addEventListener('mousedown', function(e) {
                e.preventDefault();
                startX = e.clientX;
                startWidth = parseInt(document.defaultView.getComputedStyle(panel).width, 10);
                window.addEventListener('mousemove', handleMouseMove);
                window.addEventListener('mouseup', handleMouseUp);
            });
            function handleMouseMove(e) {
                const dx = e.clientX - startX;
                panel.style.width = (startWidth + dx) + 'px';
                onWindowResize();
            }
            function handleMouseUp() {
                window.removeEventListener('mousemove', handleMouseMove);
                window.removeEventListener('mouseup', handleMouseUp);
            }
        }

        function setupEventListeners() {
            document.querySelectorAll('#controlsContent input, #controlsContent select').forEach(el => {
                // This generic listener will handle all inputs that don't have specific sync logic
                el.addEventListener(el.tagName.toLowerCase() === 'select' ? 'change' : 'input', () => {
                    if (el.id === 'crystalSystem') {
                        handleCrystalSystemChange(); // This calls updateVisualization itself
                    } else {
                        updateVisualization();
                    }
                });
            });

            // --- Lattice Parameter Validation --- [SOLUTION ADDED HERE]
            ['a', 'b', 'c'].forEach(param => {
                const inputElement = document.getElementById(param);
                if (inputElement) {
                    inputElement.addEventListener('change', (event) => {
                        const minValue = parseFloat(event.target.min) || 0.1;
                        let value = parseFloat(event.target.value);
                        if (isNaN(value) || value < minValue) {
                            event.target.value = minValue;
                            updateVisualization();
                        }
                    });
                }
            });

            // --- Rotation Controls Synchronization ---
            ['X', 'Y', 'Z'].forEach(ax => {
                const slider = document.getElementById(`rot${ax}_slider`);
                const numberInput = document.getElementById(`rot${ax}`);

                slider.addEventListener('input', () => {
                    numberInput.value = slider.value;
                    updateVisualization();
                });
                numberInput.addEventListener('input', () => {
                    slider.value = numberInput.value;
                    updateVisualization();
                });
                numberInput.addEventListener('change', () => { // Clamp value on blur/enter
                    let val = parseFloat(numberInput.value);
                    const min = parseFloat(slider.min);
                    const max = parseFloat(slider.max);
                    if (isNaN(val) || val < min) { numberInput.value = min; }
                    if (val > max) { numberInput.value = max; }
                    slider.value = numberInput.value;
                    updateVisualization();
                });
            });
            
            // --- Lambda Controls Synchronization ---
            const lambdaMinSlider = document.getElementById('lambda_min_slider');
            const lambdaMaxSlider = document.getElementById('lambda_max_slider');
            const lambdaMinInput = document.getElementById('lambda_min');
            const lambdaMaxInput = document.getElementById('lambda_max');

            function updateLambdaControls(source) {
                let minVal, maxVal;

                if (source === 'min_slider') {
                    minVal = parseFloat(lambdaMinSlider.value);
                    lambdaMinInput.value = minVal.toFixed(1);
                } else if (source === 'min_input') {
                    minVal = parseFloat(lambdaMinInput.value);
                    if(isNaN(minVal)) return;
                    lambdaMinSlider.value = minVal;
                } else if (source === 'max_slider') {
                    maxVal = parseFloat(lambdaMaxSlider.value);
                    lambdaMaxInput.value = maxVal.toFixed(1);
                } else if (source === 'max_input') {
                    maxVal = parseFloat(lambdaMaxInput.value);
                    if(isNaN(maxVal)) return;
                    lambdaMaxSlider.value = maxVal;
                }
                
                minVal = parseFloat(lambdaMinSlider.value);
                maxVal = parseFloat(lambdaMaxSlider.value);

                if (minVal >= maxVal) {
                    if (source.startsWith('min')) {
                        const newMax = Math.min(parseFloat(lambdaMaxSlider.max), minVal + parseFloat(lambdaMinSlider.step));
                        lambdaMaxSlider.value = newMax;
                        lambdaMaxInput.value = newMax.toFixed(1);
                    } else { // source starts with 'max'
                        const newMin = Math.max(parseFloat(lambdaMinSlider.min), maxVal - parseFloat(lambdaMinSlider.step));
                        lambdaMinSlider.value = newMin;
                        lambdaMinInput.value = newMin.toFixed(1);
                    }
                }
                updateVisualization();
            }
            lambdaMinSlider.addEventListener('input', () => updateLambdaControls('min_slider'));
            lambdaMinInput.addEventListener('input', () => updateLambdaControls('min_input'));
            lambdaMaxSlider.addEventListener('input', () => updateLambdaControls('max_slider'));
            lambdaMaxInput.addEventListener('input', () => updateLambdaControls('max_input'));


            // --- Detector Distance Synchronization ---
            const distanceSlider = document.getElementById('detectorDistance_slider');
            const distanceInput = document.getElementById('detectorDistance');
            
            distanceSlider.addEventListener('input', () => {
                distanceInput.value = distanceSlider.value;
                updateVisualization();
            });
            distanceInput.addEventListener('input', () => {
                distanceSlider.value = distanceInput.value;
                updateVisualization();
            });
            distanceInput.addEventListener('change', () => { // Clamp value on blur
                let val = parseFloat(distanceInput.value);
                const min = parseFloat(distanceSlider.min);
                const max = parseFloat(distanceSlider.max);
                if (isNaN(val) || val < min) { distanceInput.value = min; }
                if (val > max) { distanceInput.value = max; }
                distanceSlider.value = distanceInput.value;
                updateVisualization();
            });


            // --- Detector Diameter Synchronization ---
            const diameterSlider = document.getElementById('detectorDiameter_slider');
            const diameterInput = document.getElementById('detectorDiameter');
            
            diameterSlider.addEventListener('input', () => {
                diameterInput.value = diameterSlider.value;
                redrawDetector();
            });
            diameterInput.addEventListener('input', () => {
                diameterSlider.value = diameterInput.value;
                redrawDetector();
            });
            diameterInput.addEventListener('change', () => { // Clamp value on blur
                let val = parseFloat(diameterInput.value);
                const min = parseFloat(diameterSlider.min);
                const max = parseFloat(diameterSlider.max);
                if (isNaN(val) || val < min) { diameterInput.value = min; }
                if (val > max) { diameterInput.value = max; }
                diameterSlider.value = diameterInput.value;
                redrawDetector();
            });


            detectorCanvas.addEventListener('contextmenu', e => e.preventDefault(), false);
            detectorCanvas.addEventListener('wheel', onDetectorWheel, { passive: false });
            detectorCanvas.addEventListener('mousedown', onDetectorMouseDown, false);
            window.addEventListener('mousemove', onDetectorMouseMove, false);
            window.addEventListener('mouseup', onDetectorMouseUp, false);
            detectorCanvas.addEventListener('touchstart', onDetectorTouchStart, { passive: false });
            detectorCanvas.addEventListener('touchmove', onDetectorTouchMove, { passive: false });
            detectorCanvas.addEventListener('touchend', onDetectorTouchEnd, false);
            window.addEventListener('resize', onWindowResize, false);
        }
        
        function handleCrystalSystemChange() {
            const system = document.getElementById('crystalSystem').value;
            const visibleRows = { 'triclinic':['a','b','c','alpha','beta','gamma'], 'monoclinic':['a','b','c','beta'], 'orthorhombic':['a','b','c'], 'tetragonal':['a','c'], 'trigonal':['a','alpha'], 'hexagonal':['a','c'], 'cubic':['a'] };
            ['a','b','c','alpha','beta','gamma'].forEach(p => { document.getElementById(`row_${p}`).style.display = 'none'; });
            visibleRows[system].forEach(p => { document.getElementById(`row_${p}`).style.display = 'contents'; });

            const bravaisSelect = document.getElementById('bravaisLattice');
            const currentBravais = bravaisSelect.value;
            bravaisSelect.innerHTML = '';
            bravaisOptions[system].forEach(opt => {
                const option = document.createElement('option');
                option.value = opt;
                option.textContent = {P:"Primitive", C:"C-Base", I:"Body-Centered", F:"Face-Centered", R:"Rhombohedral"}[opt] || opt;
                bravaisSelect.appendChild(option);
            });
            if (bravaisOptions[system].includes(currentBravais)) { bravaisSelect.value = currentBravais; }
            updateVisualization();
        }
        
        function updateVisualization() {
            detectorSpots = [];
            highlightedSpot = null;
            const params = getLatticeParameters();
            if (Object.values(params).some(isNaN)) { redrawDetector(); return; }
            if (!updateReciprocalMatrix(params)) { hklInfoDiv.textContent = "Invalid cell"; redrawDetector(); return; }
            const bravaisType = document.getElementById('bravaisLattice').value;
            const hkl_range = ['h','k','l'].reduce((acc, v) => ({...acc, [v+'_min']:parseInt(document.getElementById(v+'_min').value), [v+'_max']:parseInt(document.getElementById(v+'_max').value)}), {});
            if (Object.values(hkl_range).some(isNaN)) { redrawDetector(); return; }
            
            const allPoints = [];
            for (let h=hkl_range.h_min; h<=hkl_range.h_max; h++) {
                for (let k=hkl_range.k_min; k<=hkl_range.k_max; k++) {
                    for (let l=hkl_range.l_min; l<=hkl_range.l_max; l++) {
                        if (h===0&&k===0&&l===0) continue;
                        if (isReflectionAllowed(h,k,l,bravaisType)) {
                            const pos = new THREE.Vector3(h,k,l).applyMatrix3(reciprocalMatrix);
                            if (pos) allPoints.push({ h,k,l,pos });
                        }
                    }
                }
            }
            runLaueSimulation(allPoints);
            redrawDetector();
        }

        function getLatticeParameters() {
            const system = document.getElementById('crystalSystem').value;
            let a=parseFloat(document.getElementById('a').value), b=parseFloat(document.getElementById('b').value), c=parseFloat(document.getElementById('c').value);
            let alpha=parseFloat(document.getElementById('alpha').value), beta=parseFloat(document.getElementById('beta').value), gamma=parseFloat(document.getElementById('gamma').value);
            switch(system){ case 'cubic':b=a;c=a;alpha=90;beta=90;gamma=90;break; case 'tetragonal':b=a;alpha=90;beta=90;gamma=90;break; case 'orthorhombic':alpha=90;beta=90;gamma=90;break; case 'hexagonal':b=a;alpha=90;beta=90;gamma=120;break; case 'trigonal':b=a;c=a;beta=alpha;gamma=alpha;break; case 'monoclinic':alpha=90;gamma=90;break; }
            return {a,b,c,alpha,beta,gamma};
        }
        function updateReciprocalMatrix(p) {
            const d2r = Math.PI/180, cosA=Math.cos(p.alpha*d2r), sinA=Math.sin(p.alpha*d2r), cosB=Math.cos(p.beta*d2r), sinB=Math.sin(p.beta*d2r), cosG=Math.cos(p.gamma*d2r), sinG=Math.sin(p.gamma*d2r);
            const v_term = 1-cosA**2-cosB**2-cosG**2+2*cosA*cosB*cosG;
            if(v_term<=1e-9)return false;
            const vol=p.a*p.b*p.c*Math.sqrt(v_term);
            const a_vec=new THREE.Vector3(p.a,0,0), b_vec=new THREE.Vector3(p.b*cosG, p.b*sinG,0), c_vec=new THREE.Vector3(p.c*cosB, p.c*(cosA-cosB*cosG)/sinG, vol/(p.a*p.b*sinG));
            const a_star_vec=new THREE.Vector3().crossVectors(b_vec,c_vec).divideScalar(vol), b_star_vec=new THREE.Vector3().crossVectors(c_vec,a_vec).divideScalar(vol), c_star_vec=new THREE.Vector3().crossVectors(a_vec,b_vec).divideScalar(vol);
            reciprocalMatrix.set(a_star_vec.x,b_star_vec.x,c_star_vec.x, a_star_vec.y,b_star_vec.y,c_star_vec.y, a_star_vec.z,b_star_vec.z,c_star_vec.z);
            return true;
        }
        function isReflectionAllowed(h,k,l,bravaisType){switch(bravaisType){case 'P':return true;case 'I':return (h+k+l)%2===0;case 'F':return (h%2===k%2)&&(k%2===l%2);case 'C':return (h+k)%2===0;case 'R':return (-h+k+l)%3===0;default:return true;}}
        
        function onDetectorWheel(e){
            e.preventDefault();
            const distInput = document.getElementById('detectorDistance');
            const distSlider = document.getElementById('detectorDistance_slider');
            let currentDist = parseFloat(distInput.value);
            const step = 2;
            currentDist -= Math.sign(e.deltaY) * step;
            currentDist = Math.max(5, Math.min(200, currentDist)); 
            distInput.value = Math.round(currentDist);
            distSlider.value = Math.round(currentDist);
            updateVisualization();
        }
        
        function onDetectorMouseDown(event) {
            if(event.button===0){isPanning=true;isDragging=false;mouseDownPosition.set(event.clientX,event.clientY);}
        }
        
        function onDetectorMouseMove(e){
            if(isPanning){
                const cur = new THREE.Vector2(e.clientX,e.clientY);
                if(mouseDownPosition.distanceTo(cur) > 2){
                    isDragging = true;
                    detectorContainer.style.cursor = 'grabbing';
                }
                if(isDragging){
                    const rotXInput = document.getElementById('rotX');
                    const rotYInput = document.getElementById('rotY');
                    const rotXSlider = document.getElementById('rotX_slider');
                    const rotYSlider = document.getElementById('rotY_slider');

                    const dx = e.clientX - mouseDownPosition.x;
                    const dy = e.clientY - mouseDownPosition.y;
                    const sensitivity = 0.25;

                    let newRotY = parseFloat(rotYInput.value) + dx * sensitivity;
                    let newRotX = parseFloat(rotXInput.value) + dy * sensitivity;

                    newRotY = Math.max(parseFloat(rotYSlider.min), Math.min(parseFloat(rotYSlider.max), newRotY));
                    newRotX = Math.max(parseFloat(rotXSlider.min), Math.min(parseFloat(rotXSlider.max), newRotX));
                    
                    rotYInput.value = newRotY.toFixed(0);
                    rotXInput.value = newRotX.toFixed(0);
                    rotYSlider.value = newRotY.toFixed(0);
                    rotXSlider.value = newRotX.toFixed(0);

                    mouseDownPosition.copy(cur);
                    updateVisualization();
                }
            }
        }
        function onDetectorMouseUp(e){
            if(e.button===0){
                if(!isDragging){
                    identifyDetectorSpot(e);
                }
                isPanning=false;
                isDragging=false;
                detectorContainer.style.cursor='default';
            }
        }
        
        function onDetectorTouchStart(e){e.preventDefault();if(e.touches.length===1){isPanning=true;isDragging=false;mouseDownPosition.set(e.touches[0].clientX,e.touches[0].clientY);}else if(e.touches.length===2){isPanning=false;const dx=e.touches[0].clientX-e.touches[1].clientX,dy=e.touches[0].clientY-e.touches[1].clientY;lastTouchDistance=Math.sqrt(dx*dx+dy*dy);lastTouchCenter={x:(e.touches[0].clientX+e.touches[1].clientX)/2,y:(e.touches[0].clientY+e.touches[1].clientY)/2};}}
        function onDetectorTouchMove(e){
            e.preventDefault();
            if(e.touches.length===1&&isPanning){
                const cur=new THREE.Vector2(e.touches[0].clientX,e.touches[0].clientY);
                if(mouseDownPosition.distanceTo(cur)>5) isDragging=true;
                if(isDragging){
                    const rotXInput = document.getElementById('rotX');
                    const rotYInput = document.getElementById('rotY');
                    const rotXSlider = document.getElementById('rotX_slider');
                    const rotYSlider = document.getElementById('rotY_slider');
                    const dx = e.touches[0].clientX - mouseDownPosition.x;
                    const dy = e.touches[0].clientY - mouseDownPosition.y;
                    const sensitivity = 0.25;
                    let newRotY = parseFloat(rotYInput.value) + dx * sensitivity;
                    let newRotX = parseFloat(rotXInput.value) + dy * sensitivity;
                    newRotY = Math.max(parseFloat(rotYSlider.min), Math.min(parseFloat(rotYSlider.max), newRotY));
                    newRotX = Math.max(parseFloat(rotXSlider.min), Math.min(parseFloat(rotXSlider.max), newRotX));
                    rotYInput.value = newRotY.toFixed(0);
                    rotXInput.value = newRotX.toFixed(0);
                    rotYSlider.value = newRotY.toFixed(0);
                    rotXSlider.value = newRotX.toFixed(0);

                    mouseDownPosition.set(e.touches[0].clientX, e.touches[0].clientY);
                    updateVisualization();
                }
            } else if(e.touches.length===2){
                const dx=e.touches[0].clientX-e.touches[1].clientX;
                const dy=e.touches[0].clientY-e.touches[1].clientY;
                const newDist=Math.sqrt(dx*dx+dy*dy);
                const distInput = document.getElementById('detectorDistance');
                let currentDist = parseFloat(distInput.value);
                currentDist *= lastTouchDistance / newDist;
                currentDist = Math.max(10, Math.min(200, currentDist)); 
                distInput.value = Math.round(currentDist);
                lastTouchDistance = newDist;
                updateVisualization();
            }
        }
        function onDetectorTouchEnd(e){if(!isDragging&&e.touches.length===0){identifyDetectorSpot({clientX:mouseDownPosition.x,clientY:mouseDownPosition.y});}isPanning=false;isDragging=false;lastTouchDistance=0;lastTouchCenter=null;}

        function identifyDetectorSpot(event) {
            if (detectorSpots.length === 0) return;
            const rect = detectorCanvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            let closestSpot = null, minDistanceSq = Infinity;
            
            const pixels_per_mm = 5;
            const centerX=detectorCanvas.width/2;
            const centerY=detectorCanvas.height/2;

            for (const spot of detectorSpots) {
                const canvasX = centerX + spot.x_2d * pixels_per_mm;
                const canvasY = centerY - spot.y_2d * pixels_per_mm;
                const distSq = (x - canvasX)**2 + (y - canvasY)**2;
                if (distSq < minDistanceSq) {
                    minDistanceSq = distSq;
                    closestSpot = spot;
                }
            }
            
            function gcd(a, b) { return b === 0 ? a : gcd(b, a % b); }
            function gcdOfThree(a, b, c) {
                let absA = Math.abs(a);
                let absB = Math.abs(b);
                let absC = Math.abs(c);
                return gcd(gcd(absA, absB), absC);
            }

            if (closestSpot && minDistanceSq < 100) {
                const { h, k, l } = closestSpot;
                const commonDivisor = gcdOfThree(h, k, l);
                const h_reduced = (commonDivisor === 0) ? h : h / commonDivisor;
                const k_reduced = (commonDivisor === 0) ? k : k / commonDivisor;
                const l_reduced = (commonDivisor === 0) ? l : l / commonDivisor;
                hklInfoDiv.textContent = `Spot (hkl): (${h_reduced},${k_reduced},${l_reduced})`;
                highlightedSpot = closestSpot;
                redrawDetector();
            }
        }
        
        function runLaueSimulation(points) {
            const euler=new THREE.Euler(...['X','Y','Z'].map(ax=>THREE.MathUtils.degToRad(parseFloat(document.getElementById('rot'+ax).value)||0)));
            const lambda_min=parseFloat(document.getElementById('lambda_min').value),lambda_max=parseFloat(document.getElementById('lambda_max').value);
            if(isNaN(lambda_min)||isNaN(lambda_max)||lambda_min<=0||lambda_max<=lambda_min)return;
            const k_min=1/lambda_max, k_max=1/lambda_min;
            const tempPos=new THREE.Vector3();
            points.forEach(p=>{
                tempPos.copy(p.pos).applyEuler(euler);
                const g_sq=tempPos.lengthSq(), g_z=tempPos.z;
                if(g_z>=-1e-6)return;
                const k_diff=-g_sq/(2*g_z);
                if(k_diff>=k_min&&k_diff<=k_max)projectLaueSpot(tempPos,k_diff,p);
            });
        }
        
        function projectLaueSpot(reciprocalPoint,k,pointData){
            const dist=parseFloat(document.getElementById('detectorDistance').value);
            const pos=document.getElementById('detectorPosition').value;
            const k_f=new THREE.Vector3().addVectors(reciprocalPoint,new THREE.Vector3(0,0,k));
            const target_z=(pos==='transmission')?dist:-dist;
            if(Math.abs(k_f.z)<1e-6)return;
            const t=target_z/k_f.z;
            if(t<0)return;
            detectorSpots.push({x_2d:t*k_f.x,y_2d:t*k_f.y,h:pointData.h,k:pointData.k,l:pointData.l});
        }
        
        function redrawDetector() {
            if (!detectorCtx) return;
            detectorCtx.fillStyle='#1a1a2a';
            detectorCtx.fillRect(0,0,detectorCanvas.width,detectorCanvas.height);
            
            const pixels_per_mm = 5;
            const centerX = detectorCanvas.width/2;
            const centerY = detectorCanvas.height/2;

            // Draw Detector Overlay
            const diameter_mm = parseFloat(document.getElementById('detectorDiameter').value);
            const radius_px = (diameter_mm / 2) * pixels_per_mm;
            detectorCtx.beginPath();
            detectorCtx.arc(centerX, centerY, radius_px, 0, 2 * Math.PI);
            detectorCtx.strokeStyle = 'rgba(200, 200, 200, 0.5)';
            detectorCtx.lineWidth = 2;
            detectorCtx.setLineDash([5, 5]); // Make the line dashed
            detectorCtx.stroke();
            detectorCtx.setLineDash([]); // Reset to solid line for other strokes
            
            // Draw Spots
            const detectorRadius_mm = diameter_mm / 2;
            detectorSpots.forEach(spot => {
                const isHighlighted=(highlightedSpot===spot);
                const distanceFromCenter_mm = Math.sqrt(spot.x_2d**2 + spot.y_2d**2);

                let spotColor = isHighlighted ? '#ff4444' : '#ffff00';
                
                if (distanceFromCenter_mm > detectorRadius_mm) {
                    if (!isHighlighted) {
                        spotColor = 'rgba(128, 128, 128, 0.5)';
                    }
                }

                const canvasX=centerX+spot.x_2d*pixels_per_mm;
                const canvasY=centerY-spot.y_2d*pixels_per_mm;
                
                detectorCtx.beginPath();
                detectorCtx.arc(canvasX,canvasY,isHighlighted?6:3.5,0,2*Math.PI);
                detectorCtx.fillStyle=spotColor;
                detectorCtx.fill();
                detectorCtx.strokeStyle='black';
                detectorCtx.lineWidth=0.5;
                detectorCtx.stroke();
            });
        }

        function onWindowResize() {
            const detContainer=document.getElementById('detectorContainer');
            if(!detContainer)return;
            const detWidth=detContainer.clientWidth,detHeight=detContainer.clientHeight;
            if(detWidth>0&&detHeight>0){detectorCanvas.width=detWidth;detectorCanvas.height=detHeight;}
            updateVisualization();
        }

        function animate(){requestAnimationFrame(animate);}
        window.addEventListener('load',init);

    </script>
</body>
</html>