<!DOCTYPE html>
<html>
<head>
    <title>Laue Diagram Simulator & Indexer</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
     <script src="https://cdn.tailwindcss.com"></script>

    <style>
        :root {
            --dark-bg: #111827;
            --medium-bg: #1f2937;
            --light-bg: #374151;
            --border-color: #4b5563;
            --primary-accent: #1a73e8;
            --primary-accent-hover: #1765cc;
            --text-light: #e5e7eb;
            --text-medium: #d1d5db;
            --text-dark: #9ca3af;
            --success-green: #16a34a;
            --error-red: #dc2626;
            --led-gray: #6b7280;
        }

        /* Simple transition for tab content */
        .tab-content { display: none; }
        .tab-content.active { display: block; }
        .hidden { display: none !important; }
        

        /* For Chrome, Safari, Edge, Opera */
        input[type=number]::-webkit-inner-spin-button,
        input[type=number]::-webkit-outer-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
        /* For Firefox */
        input[type=number] {
            -moz-appearance: textfield;
        }
        


        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            display: flex;
            height: 100vh;
            overflow: hidden;
            background-color: var(--dark-bg);
        }
        #appContainer { 
            display: flex; 
            flex-direction: row; 
            width: 100%; 
            height: 100%; 
            background-color: var(--dark-bg);
        }
        #controlsPanel {
            width: 380px;
            flex-shrink: 0;
            background-color: var(--dark-bg);
            color: var(--text-medium);
            height: 100%;
            display: flex;
            flex-direction: column;
            border-right: 1px solid var(--border-color);
        }
        #controlsHeader { 
            padding: 0;
            border-bottom: none;
        }
        #tabNav { 
            display: flex; 
            border-bottom: 1px solid var(--border-color);
            margin-bottom: 1rem;
        }
        .tab-link {
            flex: 1;
            padding: 0.75rem 1rem;
            cursor: pointer;
            border-bottom: 3px solid transparent;
            font-weight: 600;
            color: var(--text-dark);
            transition: all 0.2s ease;
            text-align: center;
        }
        .tab-link:hover { 
            color: var(--text-light);
        }
        .tab-link.active {
            color: var(--primary-accent);
            border-bottom-color: var(--primary-accent);
        }
        #controlsBody { 
            flex-grow: 1; 
            overflow-y: auto; 
            padding: 1.25rem; 
        }
        #controlsFooter {
            padding: 1rem;
            border-top: 1px solid var(--border-color);
            background-color: var(--dark-bg);
        }
        #statusInfo { color: var(--text-dark); }
        #fomInfo { color: var(--success-green); }
        
        #mainView { 
            flex-grow: 1; 
            display: flex; 
            position: relative; 
            background-color: var(--medium-bg);
        }
        #detectorContainer {
            width: 100%; height: 100%; position: relative;
            cursor: default;
           background-color: var(--dark-bg);
        }
        #experimentCanvas, #detectorCanvas {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            transition: filter 0.1s ease;
        }
        #experimentCanvas { z-index: 0; }
        #detectorCanvas { z-index: 1; background: transparent; }
        #detectorContainer.setting-mode { cursor: none; }

        /* Custom cursor for setting modes */
        #customCursor {
            position: absolute; 
            width: 30px; 
            height: 30px;
            border: 2px solid var(--primary-accent);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 1000; display: none;
            box-shadow: 0 0 10px var(--primary-accent); 
        }
        
                #zoomCanvas {
            position: absolute;
            width: 120px;
            height: 120px;
            border-radius: 6px;
            border: 2px solid var(--primary-accent);
            box-shadow: 0 4px 10px rgba(0,0,0,0.4);
            display: none; /* Hidden by default */
            pointer-events: none; /* Pass clicks through */
            background-color: #000; /* Fallback */
            /* Crispy pixels for magnification */
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
            z-index: 999;
        }


        #helpButton {
            position: absolute;
            top: 15px;
            right: 15px;
            width: 32px;
            height: 32px;
            background-color: var(--primary-accent);
            color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            font-weight: bold;
            text-decoration: none;
            z-index: 1001;
            transition: background-color 0.2s ease;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
        }
        #helpButton:hover {
            background-color: var(--primary-accent-hover);
        }
  

        /* Form Elements (Re-styled to match combs) */
        .form-label {
            display: block;
            font-weight: 500;
            color: var(--text-dark);
            margin-bottom: 0.5rem;
            font-size: 0.875rem;
        }
        .form-input, .form-select {
            width: 100%;
            padding: 0.5rem 0.75rem;
            border: 1px solid var(--border-color);
            border-radius: 0.35rem;
            background-color: var(--light-bg);
            color: var(--text-light);
            box-shadow: none;
            transition: border-color 0.2s ease, box-shadow 0.2s ease;
        }
        .form-input:focus, .form-select:focus {
            outline: none;
            border-color: var(--primary-accent);
            box-shadow: 0 0 0 2px rgba(26, 115, 232, 0.4);
        }
    
        .form-input-output {
             width: 100%;
            padding: 0.5rem 0.75rem;
            border: 1px solid var(--border-color);
            border-radius: 0.35rem;
            background-color: var(--dark-bg); /* Darker background */
            color: var(--text-light);
            cursor: default;
        }
        
        .form-input-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.75rem 1rem;
            align-items: center;
        }
        .form-input-grid > .span-2 { grid-column: span 2; }
        
    
        .form-slider {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 32px; /* <-- from combs.html */
            background: var(--medium-bg); /* <-- from combs.html */
            border-radius: 6px; 
            outline: none;
            padding: 0; 
            margin: 0; 
        }
        .form-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 15px; 
            height: 15px; 
            background: var(--primary-accent);
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid var(--text-light); 
            box-sizing: border-box; 
            box-shadow: 0 2px 4px rgba(0,0,0,0.25);
        }
        .form-slider::-moz-range-thumb {
            width: 15px;
            height: 15px;
            background: var(--primary-accent);
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid var(--text-light); 
            box-sizing: border-box;
            box-shadow: 0 2px 4px rgba(0,0,0,0.25); /
        }
        .form-slider:disabled {
            background: var(--light-bg); 
        }
        .form-slider:disabled::-webkit-slider-thumb {
            background: var(--border-color); 
        }
        .form-slider:disabled::-moz-range-thumb {
            background: var(--border-color); 
        }
    


        /* Buttons (Re-styled to match combs) */
        .btn {
            width: 100%;
            padding: 0.6rem 1rem;
            font-weight: 600;
            border-radius: 0.375rem;
            border: none;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .btn-primary { 
            background-color: var(--primary-accent);
            color: white; 
        }
        .btn-primary:hover:not(:disabled) { 
            background-color: var(--primary-accent-hover);
        }
        .btn-primary:disabled { 
            background-color: var(--border-color);
            opacity: 0.7;
            cursor: not-allowed; 
        }
        .btn-secondary { 
            background-color: var(--light-bg);
            color: var(--text-light);
        }
        .btn-secondary:hover:not(:disabled) { 
            background-color: #4a5568;
        }
        .btn-secondary:disabled { 
            background-color: var(--border-color);
            color: var(--text-dark);
            opacity: 0.7;
            cursor: not-allowed; 
        }
        .btn-danger { 
            background-color: var(--error-red);
            color: var(--text-light);
        }
        .btn-danger:hover { 
            background-color: #b91c1c;
        }

       
        .info-section {
            margin-bottom: 1.5rem;
            padding-top: 1.5rem;
            border-top: 1px solid var(--border-color);
        }
        .info-section:first-child {
            border-top: none;
            padding-top: 0;
        }
        
    
        #peakList { list-style-type: none; padding: 0; margin: 0; max-height: 200px; overflow-y: auto; }
        #peakList li {
            display: grid;
            grid-template-columns: 25px 1fr 1fr 30px;
            gap: 5px;
            align-items: center;
            padding: 4px;
            border-radius: 4px;
        }
        #peakList li.selected { 
            background-color: var(--light-bg);
        }
        #peakList li label { 
            font-weight: bold; 
            cursor: pointer; 
            text-align: center; 
            color: var(--text-medium);
        }
        #peakList input { 
            font-size: 0.9em; 
            padding: 4px; 
            text-align: center; 
            border: 1px solid var(--border-color);
            border-radius: 4px; 
            background-color: var(--medium-bg);
            color: var(--text-light);
        }
        #peakList input:focus {
            background-color: var(--light-bg);
            border-color: var(--primary-accent);
            outline: none;
        }
        #peakList button { 
            padding: 2px 4px; 
            font-size: 0.9em; 
            color: var(--error-red);
            background-color: var(--light-bg);
            border: 1px solid var(--border-color);
            border-radius: 4px; 
        }
        
        
        #solutionsList { display: flex; flex-direction: column; gap: 0.5rem; }
        .solution-item {
            padding: 0.75rem;
            border: 1px solid var(--border-color);
            border-radius: 0.375rem;
            background: var(--medium-bg);
            cursor: pointer;
            transition: background-color 0.2s ease;
            color: var(--text-medium);
        }
        .solution-item:hover { 
            background-color: var(--light-bg);
        }
        .solution-item.selected { 
            background-color: var(--primary-accent);
            border-color: var(--primary-accent);
            color: var(--text-light);
        }
        .solution-item .text-sm { /* Override tailwind gray */
            color: var(--text-dark) !important;
        }
        .solution-item.selected .text-sm {
            color: var(--text-light) !important;
        }

    </style>

</head>
<body>
    <div id="appContainer">
        <div id="controlsPanel">
            
            <div id="tabNav">
                <span class="tab-link active" data-tab="set">Set</span>
                <span class="tab-link" data-tab="analysis">Analysis</span>
                <span class="tab-link" data-tab="solutions">Solutions</span>
                <span class="tab-link" data-tab="orient">Orient</span>
            </div>

            <div id="controlsBody">
                
                <div id="setTabContent" class="tab-content active">
                    <div class="info-section">
                        <label for="bravaisLattice" class="form-label">Lattice</label>
                        <select id="bravaisLattice" class="form-select"></select>
                    </div>

                    <div class="info-section">
                        <span class="form-label">Lattice Parameters</span>
                        <div id="latticeParamsContainer" class="form-input-grid">
                            <div id="row_a" style="display: contents;">
                                <label for="a">a (Å)</label> <input type="number" id="a" value="6.0" step="0.1" min="1" class="form-input">
                            </div>
                            <div id="row_b" style="display: contents;">
                                <label for="b">b (Å)</label> <input type="number" id="b" value="7.0" step="0.1" min="1" class="form-input">
                            </div>
                            <div id="row_c" style="display: contents;">
                                <label for="c">c (Å)</label> <input type="number" id="c" value="8.0" step="0.1" min="1" class="form-input">
                            </div>
                            <div id="row_alpha" style="display: contents;">
                                <label for="alpha">α (°)</label> <input type="number" id="alpha" value="90.0" step="0.1" class="form-input">
                            </div>
                            <div id="row_beta" style="display: contents;">
                                <label for="beta">β (°)</label> <input type="number" id="beta" value="90.0" step="0.1" class="form-input">
                            </div>
                            <div id="row_gamma" style="display: contents;">
                                <label for="gamma">γ (°)</label> <input type="number" id="gamma" value="90.0" step="0.1" class="form-input">
                            </div>
                        </div>
                    </div>

                    <div class="info-section">
                        <span class="form-label">X-Ray Source (Laue)</span>
                        <div class="form-input-grid" style="grid-template-columns: auto 1fr 65px;">
                            <label for="lambda_min">λ_min (Å)</label>
                            <input type="range" id="lambda_min_slider" value="0.2" min="0.1" max="2.0" step="0.1" class="form-slider">
                            <input type="number" id="lambda_min" value="0.2" min="0.1" max="2.0" step="0.1" class="form-input">
                            
                            <label for="lambda_max">λ_max (Å)</label>
                            <input type="range" id="lambda_max_slider" value="3.0" min="0.2" max="5.0" step="0.1" class="form-slider">
                            <input type="number" id="lambda_max" value="3.0" min="0.2" max="5.0" step="0.1" class="form-input">
                        </div>
                    </div>

                   
                    <div class="info-section">
                        <span class="form-label">Detector Geometry</span>
                        <div class="form-input-grid" style="grid-template-columns: 1fr 1fr; gap: 1rem;">
                            
                            <!-- NEW Detector Angle Slider -->
                            <div class="span-2">
                                <label for="detectorAngle" class="form-label text-sm">Angle (°) <span class="font-normal text-gray-400">(0=Trans, 180=Back)</span></label>
                                <div class="grid grid-cols-[1fr,65px] gap-2 items-center">
                                    <input type="range" id="detectorAngle_slider" value="180" min="0" max="180" step="1" class="form-slider">
                                    <input type="number" id="detectorAngle" value="180" min="0" max="180" step="1" class="form-input">
                                </div>
                            </div>
                            
                            <div class="span-2">
                                <label for="detectorDistance" class="form-label text-sm">Dist. (mm)</label>
                                <div class="grid grid-cols-[1fr,65px] gap-2 items-center">
                                    <input type="range" id="detectorDistance_slider" value="36" min="5" max="200" step="1" class="form-slider">
                                    <input type="number" id="detectorDistance" value="36" min="5" max="200" step="1" class="form-input">
                                </div>
                            </div>
                        </div>
                    </div>
              
                    
                    <div class="info-section">
                        <span class="form-label">Goniometer Rotation (°)</span>
                        <p class="text-sm text-gray-600 mb-3" style="color: var(--text-dark);">
                            Represents the physical goniometer controls, relative to the orientation found in the 'Analysis' tab.
                        </p>
                        <div class="form-input-grid" style="grid-template-columns: auto 1fr 60px;">
                            <label for="rotX">X:</label>
                            <input type="range" id="rotX_slider" value="0" min="-90" max="90" step="1" class="form-slider">
                            <input type="number" id="rotX" value="0" min="-90" max="90" step="1" class="form-input">
                            
                            <label for="rotY">Y:</label>
                            <input type="range" id="rotY_slider" value="0" min="-90" max="90" step="1" class="form-slider">
                            <input type="number" id="rotY" value="0" min="-90" max="90" step="1" class="form-input">
                            
                            <label for="rotZ">Z:</label>
                            <input type="range" id="rotZ_slider" value="0" min="-90" max="90" step="1" class="form-slider">
                            <input type="number" id="rotZ" value="0" min="-90" max="90" step="1" class="form-input">
                        </div>
                    </div>
                </div>

                <div id="analysisTabContent" class="tab-content">
                    <div class="info-section">
                        <label for="imageLoader" class="form-label">Load Image</label>
                        <input type="file" id="imageLoader" accept="image/" class="form-input">
                        
                        <div class="flex items-center justify-between mt-4">
                            <div class="flex items-center">
                                <input type="checkbox" id="invertContrast" class="mr-2">
                                <label for="invertContrast">Invert Image</label>
                            </div>
                            <div class="flex items-center">
                                <input type="checkbox" id="showSimulatedSpots" class="mr-2" checked>
                                <label for="showSimulatedSpots">Show Spots</label>
                            </div>
                        </div>

                        <button id="setCenterBtn" class="btn btn-secondary mt-4" disabled>1. Set Center</button>
                        <button id="cancelModeBtn" class="btn btn-danger mt-2" style="display: none;">Cancel</button>
                    </div>

                    <div id="scaleControls" class="info-section" style="display: none;">
                        <span class="form-label">Set Scale</span>
                        <p class="text-sm text-gray-600 mb-2">Move the blue dot to a known reference point. Then enter its coordinates relative to the center.</p>
                        <div class="form-input-grid">
                            <label for="scalePointX_mm">U (mm)</label> <!-- Changed from X -->
                            <input type="number" id="scalePointX_mm" value="50" step="1" class="form-input">
                            <label for="scalePointY_mm">V (mm)</label> <!-- Changed from Y -->
                            <input type="number" id="scalePointY_mm" value="0" step="1" class="form-input">
                        </div>
                    </div>

                    <div class="info-section">
                        <span class="form-label">Experimental Peaks (U, V)</span> <!-- Changed from X, Y -->
                        <div id="peakList"></div>
                        <div class="form-input-grid mt-4">
                            <button id="findPeaksBtn" class="btn btn-primary" disabled>Find Peaks</button>
                            <button id="addPeakBtn" class="btn btn-secondary" disabled>Add Peak</button>
                        </div>
                    </div>

                </div> 

                <div id="solutionsTabContent" class="tab-content">
                    <div id="solutionsList">
                        <div class="text-gray-600">Run a search from the "Analysis" tab to see solutions here.</div>
                    </div>
                </div>

                <div id="orientTabContent" class="tab-content">
                    <div class="info-section">
                        <span class="form-label">Orient to (h,k,l)</span>
                        <p class="text-sm text-gray-600 mb-3" style="color: var(--text-dark);">
                            Align a specific (h,k,l) vector with the beam axis (to the -X direction).
                        </p>
                        <div class="form-input-grid" style="grid-template-columns: 1fr 1fr 1fr; gap: 1rem;">
                            <div>
                                <label for="orient_h" class="form-label text-sm">h</label>
                                <input type="number" id="orient_h" value="1" step="1" class="form-input">
                            </div>
                            <div>
                                <label for="orient_k" class="form-label text-sm">k</label>
                                <input type="number" id="orient_k" value="0" step="1" class="form-input">
                            </div>
                            <div>
                                <label for="orient_l" class="form-label text-sm">l</label>
                                <input type="number" id="orient_l" value="0" step="1" class="form-input">
                            </div>
                        </div>
                        <button id="orientToHKLBtn" class="btn btn-primary mt-4">Calculate Goniometer Angles</button>
                    </div>

                    <div class="info-section">
                        <span class="form-label">Required Goniometer Angles (°)</span>
                        <div class="form-input-grid" style="grid-template-columns: 1fr 1fr 1fr; gap: 1rem;">
                             <div>
                                <label for="orient_X_out" class="form-label text-sm">X</label>
                                <input type="text" id="orient_X_out" class="form-input-output" readonly>
                            </div>
                             <div>
                                <label for="orient_Y_out" class="form-label text-sm">Y</label>
                                <input type="text" id="orient_Y_out" class="form-input-output" readonly>
                            </div>
                             <div>
                                <label for="orient_Z_out" class="form-label text-sm">Z</label>
                                <input type="text" id="orient_Z_out" class="form-input-output" readonly>
                            </div>
                        </div>
                        <div id="orientStatus" class="text-sm mt-3 h-10" style="color: var(--text-medium);"></div>
                    </div>
                    
                    <div class="info-section">
                         <span class="form-label">Note</span>
                         <p class="text-sm text-gray-600" style="color: var(--text-dark);">
                            This calculates the goniometer angles (in the 'Set' tab) required to rotate from the *current base orientation* to the new target.
                            <br><br>
                            • The (h,k,l) vector is aligned to the **-X axis** (anti-parallel to the incident beam).
                            <br><br>
                            • This is the 180° back-reflection condition. The spot will appear at the center *only if* the detector is also at 180°.
                            <br><br>
                            **Important:** The aligned (h,k,l) spot will only be visible if its required wavelength is within the "X-Ray Source" range specified in the 'Set' tab.
                         </p>
                    </div>
                </div>


            </div>

            <div id="controlsFooter">
                <div id="statusInfo" class="text-sm text-gray-700 h-10 mb-2">Please load an image to begin.</div>
                <div id="fomInfo" class="text-sm font-bold text-green-700 h-6" style="display: none;">Figure of Merit will be shown here.</div>
                <button id="searchOrientBtn" class="btn btn-primary mt-2" disabled>Search Orientation</button>
                <button id="generateReportBtn" class="btn btn-secondary mt-2">Generate Report</button>
            </div>
        </div>


        <div id="mainView">
            <div id="detectorContainer">
                <canvas id="experimentCanvas"></canvas>
                <canvas id="detectorCanvas"></canvas>
                <canvas id="zoomCanvas"></canvas>
                <div id="customCursor"></div>
                
                <a href="Laue_2_help.html" target="_blank" id="helpButton">?</a>

            </div>
        </div>


    </div>
        
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>

<script>
       
        let reciprocalMatrix = new THREE.Matrix3();
        let baseOrientationMatrix = new THREE.Matrix4(); // Stores the result of the search (the "unknown" orientation)
        
        let hklInfoDiv, statusInfoDiv, peakListEl, fomInfoDiv, solutionsListDiv, orientStatusDiv;
        let detectorCanvas, detectorCtx, detectorContainer, customCursor;
        let detectorSpots = [];
        let isPanning = false, isDragging = false;
        let mouseDownPosition = new THREE.Vector2(0, 0);
        let highlightedSpot = null;
        let experimentCanvas, experimentCtx;
        
            let zoomCanvas, zoomCtx;
        const ZOOM_LEVEL = 4; // 4 fois, depuis le 1er nov
        const ZOOM_WINDOW_SIZE = 180; // in pixels

        let experimentalImage = null;
        let experimentalSpots = [];
        let orientationSolutions = []; 
        
        let imageCenter = null; 
        let scalePoint = null;  

        let pixels_per_mm_x = -1; 
        let pixels_per_mm_y = -1; 

        let imageTransform = { scale: 1, offsetX: 0, offsetY: 0 };
        
        let isSettingCenter = false, isAddingPeak = false;
        let isDraggingScalePoint = false;
        let selectedPeakIndex = null, isDraggingPeak = false;

        const HKL_RANGE = 12;
        const PEAK_COUNT = 12; // Find top 12 peaks
        
        const bravaisLatticeOptions = {
            'Cubic (P)': { system: 'cubic', type: 'P' },
            'Cubic (I)': { system: 'cubic', type: 'I' },
            'Cubic (F)': { system: 'cubic', type: 'F' },
            'Tetragonal (P)': { system: 'tetragonal', type: 'P' },
            'Tetragonal (I)': { system: 'tetragonal', type: 'I' },
            'Orthorhombic (P)': { system: 'orthorhombic', type: 'P' },
            'Orthorhombic (C)': { system: 'orthorhombic', type: 'C' },
            'Orthorhombic (I)': { system: 'orthorhombic', type: 'I' },
            'Orthorhombic (F)': { system: 'orthorhombic', type: 'F' },
            'Hexagonal (P)': { system: 'hexagonal', type: 'P' },
            'Trigonal (R)': { system: 'trigonal', type: 'R' },
            'Monoclinic (P)': { system: 'monoclinic', type: 'P' },
            'Monoclinic (C)': { system: 'monoclinic', type: 'C' },
            'Triclinic (P)': { system: 'triclinic', type: 'P' },
        };
        

        /**
         * Reads, validates, and corrects a numeric input field.
         * @param {string} id - The ID of the input field.
         * @param {number} min - The minimum allowed value.
         * @param {number} max - The maximum allowed value.
         * @param {number} defaultValue - The value to use if the current one is invalid.
         * @returns {number} The validated number.
         */
        function getValidatedNumericInput(id, min, max, defaultValue) {
            const el = document.getElementById(id);
            if (!el) return defaultValue; // Safety check
            
            let val = parseFloat(el.value);
            
            if (isNaN(val) || val < min || val > max) {
                val = defaultValue;
                el.value = val; // Write the correction back to the UI
              
                const slider = document.getElementById(id + '_slider');
                if (slider) {
                    slider.value = val;
                }
            }
            return val;
        }



        // --- UI & TAB FUNCTIONS ---
        
        function setupTabs() {
            document.querySelectorAll('.tab-link').forEach(link => {
                link.addEventListener('click', () => {
                    const tabName = link.dataset.tab;
                    setActiveTab(tabName);
                });
            });
        }
        
        function setActiveTab(tabName) {
            document.querySelectorAll('.tab-link').forEach(link => {
                link.classList.toggle('active', link.dataset.tab === tabName);
            });
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.toggle('active', content.id === `${tabName}TabContent`);
            });
        }

        function initLatticeDropdown() {
            const select = document.getElementById('bravaisLattice');
            select.innerHTML = '';
            for (const key in bravaisLatticeOptions) {
                const option = document.createElement('option');
                option.value = key;
                option.textContent = key;
                select.appendChild(option);
            }
            select.addEventListener('change', handleLatticeChange);
            handleLatticeChange(); // Call once to init
        }

        function handleLatticeChange() {
            const key = document.getElementById('bravaisLattice').value;
            const { system } = bravaisLatticeOptions[key];
            
     
            const inputs = {
                a: document.getElementById('a'),
                b: document.getElementById('b'),
                c: document.getElementById('c'),
                alpha: document.getElementById('alpha'),
                beta: document.getElementById('beta'),
                gamma: document.getElementById('gamma')
            };

    
            // This ensures that when 'a' changes in cubic, 'b' and 'c' are updated
            switch (system) {
                case 'cubic':
                    inputs.b.value = inputs.a.value;
                    inputs.c.value = inputs.a.value;
                    inputs.alpha.value = 90;
                    inputs.beta.value = 90;
                    inputs.gamma.value = 90;
                    break;
                case 'tetragonal':
                    inputs.b.value = inputs.a.value;
                    inputs.alpha.value = 90;
                    inputs.beta.value = 90;
                    inputs.gamma.value = 90;
                    break;
                case 'orthorhombic':
                    inputs.alpha.value = 90;
                    inputs.beta.value = 90;
                    inputs.gamma.value = 90;
                    break;
                case 'hexagonal':
                    inputs.b.value = inputs.a.value;
                    inputs.alpha.value = 90;
                    inputs.beta.value = 90;
                    inputs.gamma.value = 120;
                    break;
                case 'trigonal':
                    inputs.b.value = inputs.a.value;
                    inputs.c.value = inputs.a.value;
                    inputs.beta.value = inputs.alpha.value;
                    inputs.gamma.value = inputs.alpha.value;
                    break;
                case 'monoclinic':
                    inputs.alpha.value = 90;
                    inputs.gamma.value = 90;
                    break;
            }
          

            const visibleRows = {
                'triclinic': ['a', 'b', 'c', 'alpha', 'beta', 'gamma'],
                'monoclinic': ['a', 'b', 'c', 'beta'],
                'orthorhombic': ['a', 'b', 'c'],
                'tetragonal': ['a', 'c'],
                'trigonal': ['a', 'alpha'],
                'hexagonal': ['a', 'c'],
                'cubic': ['a']
            };
            ['a', 'b', 'c', 'alpha', 'beta', 'gamma'].forEach(p => {
                document.getElementById(`row_${p}`).style.display = 'none';
            });
            visibleRows[system].forEach(p => {
                document.getElementById(`row_${p}`).style.display = 'contents';
            });
            
            updateVisualization();
        }



        function setUIMode(mode) {
            isSettingCenter = (mode === 'center');
            isAddingPeak = (mode === 'add-peak');
            
            const cancelBtn = document.getElementById('cancelModeBtn');
            const setCenterBtn = document.getElementById('setCenterBtn');
            
            if (isSettingCenter || isAddingPeak) {
                cancelBtn.style.display = 'block';
                setCenterBtn.disabled = true;
                detectorContainer.classList.add('setting-mode');
                customCursor.style.display = 'block';

                 if ((isAddingPeak || isSettingCenter) && experimentalImage) { 
                    zoomCanvas.style.display = 'block';
                }

                if (isSettingCenter) statusInfoDiv.textContent = 'Click on the image to set the beam center.';
                else if (isAddingPeak) statusInfoDiv.textContent = 'Click on the image to add a new peak.';
            } else { // Idle mode
                cancelBtn.style.display = 'none';
                detectorContainer.classList.remove('setting-mode');
                customCursor.style.display = 'none';
                zoomCanvas.style.display = 'none';
                statusInfoDiv.textContent = 'Ready.';
                setCenterBtn.disabled = !experimentalImage;
                
                const scale_valid = pixels_per_mm_x > 0 && pixels_per_mm_y > 0;
                document.getElementById('addPeakBtn').disabled = !scale_valid;
            }
        }


      

        function updateScale() {
            if (!imageCenter || !scalePoint) {
                pixels_per_mm_x = -1;
                pixels_per_mm_y = -1;
                return;
            }
            
            const u_mm = parseFloat(document.getElementById('scalePointX_mm').value); // Now U
            const v_mm = parseFloat(document.getElementById('scalePointY_mm').value); // Now V
            
            if (isNaN(u_mm) || isNaN(v_mm)) {
                pixels_per_mm_x = -1;
                pixels_per_mm_y = -1;
                return;
            }

            // 1. Calculate pixel deltas from center
            const delta_raw_x = scalePoint.raw_x - imageCenter.raw_x;
            const delta_raw_y = scalePoint.raw_y - imageCenter.raw_y; // raw_y is "down"

            // 2. Calculate separate scale factors
            // We assume the image X-axis corresponds to the detector U-axis
            if (Math.abs(u_mm) < 1e-6) {
                pixels_per_mm_x = -1;
            } else {
                pixels_per_mm_x = delta_raw_x / u_mm; // pixels_per_mm_U
            }

            // We assume the image Y-axis corresponds to the detector V-axis
            if (Math.abs(v_mm) < 1e-6) {
                pixels_per_mm_y = -1;
            } else {
                // Y-axis is inverted: raw_y is "down" (positive), mm_y is "up" (positive)
                // So we need to negate the pixel delta
                pixels_per_mm_y = -delta_raw_y / v_mm; // pixels_per_mm_V
            }

            const scale_valid = pixels_per_mm_x > 0 && pixels_per_mm_y > 0;

            if (!scale_valid) {
                 statusInfoDiv.textContent = "Error: Scale coordinates must be non-zero.";
            }
            
            // Enable dependent buttons
            document.getElementById('findPeaksBtn').disabled = !scale_valid;
            document.getElementById('addPeakBtn').disabled = !scale_valid;
            
            // Re-calculate peak list coordinates
            updatePeakListUI();
            redrawDetector();
        }


        function updatePeakListUI() {
            peakListEl.innerHTML = '';
            
            const scale_valid = pixels_per_mm_x > 0 && pixels_per_mm_y > 0;
            document.getElementById('searchOrientBtn').disabled = experimentalSpots.length < 3 || !scale_valid;
            
            if (!scale_valid) return;
            
            experimentalSpots.forEach((spot, index) => {
                const li = document.createElement('li');
                if (index === selectedPeakIndex) li.classList.add('selected');
                
                const u_mm = (spot.raw_x - imageCenter.raw_x) / pixels_per_mm_x; // Now U
                const v_mm = -(spot.raw_y - imageCenter.raw_y) / pixels_per_mm_y; // Now V
                
                li.innerHTML = `<label>${index + 1}</label>
                                <input type="number" step="0.01" value="${u_mm.toFixed(3)}" data-axis="x" class="form-input">
                                <input type="number" step="0.01" value="${v_mm.toFixed(3)}" data-axis="y" class="form-input">
                                <button data-index="${index}">X</button>`;
                
                li.querySelector('label').onclick = () => {
                    selectedPeakIndex = index;
                    updatePeakListUI();
                    redrawDetector();
                };
                
                li.querySelector('button').onclick = (e) => {
                    e.stopPropagation();
                    experimentalSpots.splice(index, 1);
                    if (selectedPeakIndex === index) selectedPeakIndex = null;
                    else if (selectedPeakIndex > index) selectedPeakIndex--;
                    updatePeakListUI();
                    redrawDetector();
                };
                
                li.querySelectorAll('input').forEach(input => {
                    input.addEventListener('change', (e) => {
                        const new_u_mm = parseFloat(li.querySelector('input[data-axis="x"]').value); // U
                        const new_v_mm = parseFloat(li.querySelector('input[data-axis="y"]').value); // V
                        if (!isNaN(new_u_mm) && !isNaN(new_v_mm)) {
                            spot.raw_x = imageCenter.raw_x + (new_u_mm * pixels_per_mm_x);
                            spot.raw_y = imageCenter.raw_y - (new_v_mm * pixels_per_mm_y);
                            redrawDetector();
                        }
                    });
                });
                peakListEl.appendChild(li);
            });
        }


        function detectPeaks() {
            const scale_valid = pixels_per_mm_x > 0 && pixels_per_mm_y > 0;
            if (!experimentalImage || !imageCenter || !scale_valid) {
                statusInfoDiv.textContent = "Error: Set center and scale before finding peaks.";
                return;
            }
            
            statusInfoDiv.textContent = `Finding peaks...`;
            
            // Use setTimeout to allow the "Finding peaks..." message to render
            setTimeout(() => {
                const shouldInvert = document.getElementById('invertContrast').checked;
                
                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');
                tempCanvas.width = experimentalImage.width;
                tempCanvas.height = experimentalImage.height;
                tempCtx.drawImage(experimentalImage, 0, 0);
                
                const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
                const data = imageData.data, width = imageData.width, height = imageData.height;
                const grayscale = new Uint8Array(width * height);
                let maxIntensity = 0;

                for (let i = 0; i < data.length; i += 4) {
                    let intensity = 0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2];
                    if (shouldInvert) { intensity = 255 - intensity; }
                    grayscale[i / 4] = intensity;
                    if (intensity > maxIntensity) { maxIntensity = intensity; }
                }
                
                const threshold = maxIntensity * 0.90; // 90% threshold
                
                const exclusion_radius_mm_sq = 5**2; // 5mm exclusion radius
                const peaks = [];
                
                const neighborhood = 5; 
                const n_half = Math.floor(neighborhood / 2);

                for (let y = n_half; y < height - n_half; y++) {
                    for (let x = n_half; x < width - n_half; x++) {
                        const index = y * width + x;
                        const intensity = grayscale[index];
                        if (intensity < threshold) continue;
                        
                        const du_mm = (x - imageCenter.raw_x) / pixels_per_mm_x;
                        const dv_mm = (y - imageCenter.raw_y) / pixels_per_mm_y;
                        const dist_mm_sq = du_mm**2 + dv_mm**2;
                        if (dist_mm_sq <= exclusion_radius_mm_sq) continue;
                        
                        let isMax = true;
                        for (let dy = -n_half; dy <= n_half; dy++) {
                            for (let dx = -n_half; dx <= n_half; dx++) {
                                if (dx === 0 && dy === 0) continue;
                                if (grayscale[(y + dy) * width + (x + dx)] >= intensity) {
                                    isMax = false;
                                    break;
                                }
                            }
                            if (!isMax) break;
                        }

                        if (isMax) {
                            peaks.push({ x: x, y: y, intensity: intensity });
                        }
                    }
                }
                
                peaks.sort((a, b) => b.intensity - a.intensity);

                const quadrants = { q1: [], q2: [], q3: [], q4: [] };
                const centerX = imageCenter.raw_x;
                const centerY = imageCenter.raw_y;

                for (const peak of peaks) {
                    if (peak.x > centerX && peak.y < centerY) {
                        if (quadrants.q1.length < 3) quadrants.q1.push(peak);
                    } else if (peak.x < centerX && peak.y < centerY) {
                        if (quadrants.q2.length < 3) quadrants.q2.push(peak);
                    } else if (peak.x < centerX && peak.y > centerY) {
                        if (quadrants.q3.length < 3) quadrants.q3.push(peak);
                    } else if (peak.x > centerX && peak.y > centerY) {
                        if (quadrants.q4.length < 3) quadrants.q4.push(peak);
                    }
                }

                const finalPeaks = [
                    ...quadrants.q1,
                    ...quadrants.q2,
                    ...quadrants.q3,
                    ...quadrants.q4
                ];

                if (finalPeaks.length < 3) {
                    statusInfoDiv.textContent = `Error: Only found ${finalPeaks.length} peaks. Try inverting contrast.`;
                    experimentalSpots = [];
                    updatePeakListUI();
                    redrawDetector();
                    return;
                }
                
                experimentalSpots = finalPeaks.map(p => ({ raw_x: p.x, raw_y: p.y }));
                
                statusInfoDiv.textContent = `${experimentalSpots.length} peaks found.`;
                updatePeakListUI();
                redrawDetector();
            }, 10); // 10ms delay
        }



        // --- CORE LOGIC & SIMULATION ---

        function getLatticeParameters() {
            const key = document.getElementById('bravaisLattice').value;
            const { system } = bravaisLatticeOptions[key];

            // Use 0.1 as a minimum to prevent divide-by-zero errors
            let a = getValidatedNumericInput('a', 1, 100, 6.0);
            let b = getValidatedNumericInput('b', 1, 100, 7.0);
            let c = getValidatedNumericInput('c', 1, 100, 8.0);
            let alpha = getValidatedNumericInput('alpha', 10, 170, 90.0);
            let beta = getValidatedNumericInput('beta', 10, 170, 90.0);
            let gamma = getValidatedNumericInput('gamma', 10, 170, 90.0);

            console.log("Reading Lattice Params:", { a, b, c, alpha, beta, gamma, system });
       


            switch (system) {
                case 'cubic': b = a; c = a; alpha = 90; beta = 90; gamma = 90; break;
                case 'tetragonal': b = a; alpha = 90; beta = 90; gamma = 90; break;
                case 'orthorhombic': alpha = 90; beta = 90; gamma = 90; break;
                case 'hexagonal': b = a; alpha = 90; beta = 90; gamma = 120; break;
                case 'trigonal': b = a; c = a; beta = alpha; gamma = alpha; break;
                case 'monoclinic': alpha = 90; gamma = 90; break;
            }
            return { a, b, c, alpha, beta, gamma };
        }
        
        function updateReciprocalMatrix(p) {
            const d2r = Math.PI / 180;
            const cosA = Math.cos(p.alpha * d2r), sinA = Math.sin(p.alpha * d2r);
            const cosB = Math.cos(p.beta * d2r), sinB = Math.sin(p.beta * d2r);
            const cosG = Math.cos(p.gamma * d2r), sinG = Math.sin(p.gamma * d2r);
            const v_term = 1 - cosA**2 - cosB**2 - cosG**2 + 2 * cosA * cosB * cosG;
            if (v_term <= 1e-9) return false;
            const vol = p.a * p.b * p.c * Math.sqrt(v_term);
            const a_vec = new THREE.Vector3(p.a, 0, 0);
            const b_vec = new THREE.Vector3(p.b * cosG, p.b * sinG, 0);
            const c_vec = new THREE.Vector3(p.c * cosB, p.c * (cosA - cosB * cosG) / sinG, vol / (p.a * p.b * sinG));
            const a_star_vec = new THREE.Vector3().crossVectors(b_vec, c_vec).divideScalar(vol);
            const b_star_vec = new THREE.Vector3().crossVectors(c_vec, a_vec).divideScalar(vol);
            const c_star_vec = new THREE.Vector3().crossVectors(a_vec, b_vec).divideScalar(vol);
            reciprocalMatrix.set(a_star_vec.x, b_star_vec.x, c_star_vec.x,
                                 a_star_vec.y, b_star_vec.y, c_star_vec.y,
                                 a_star_vec.z, b_star_vec.z, c_star_vec.z);
            return true;
        }
        
        function isReflectionAllowed(h, k, l, bravaisType) {
            switch (bravaisType) {
                case 'P': return true;
                case 'I': return (h + k + l) % 2 === 0;
                case 'F': return ((h + k) % 2 === 0) && ((h + l) % 2 === 0) && ((k + l) % 2 === 0);
                case 'C': return (h + k) % 2 === 0;
                case 'R': return (-h + k + l) % 3 === 0;
                default: return true;
            }
        }

        // 1. ACCEPT the "detectorAngle" argument here
        function generateSpotsForOrientation(rotX_deg, rotY_deg, rotZ_deg, detectorAngle) { 
            const params = getLatticeParameters();
            if (Object.values(params).some(isNaN) || !updateReciprocalMatrix(params)) return [];

            const bravaisKey = document.getElementById('bravaisLattice').value;
           
            let lambda_min_val = getValidatedNumericInput('lambda_min', 0.1, 20.0, 0.2);
            let lambda_max_val = getValidatedNumericInput('lambda_max', 0.1, 20.0, 3.0);
            let dist_val = getValidatedNumericInput('detectorDistance', 1, 1000, 36);
            let angle_deg_val = getValidatedNumericInput('detectorAngle', 0, 180, detectorAngle); // Use passed-in default

            // Cross-check: ensure min is less than max
            if (lambda_min_val >= lambda_max_val) {
                lambda_min_val = lambda_max_val - 0.1;
                if (lambda_min_val < 0.1) lambda_min_val = 0.1;
                document.getElementById('lambda_min').value = lambda_min_val;
                const min_slider = document.getElementById('lambda_min_slider');
                if (min_slider) min_slider.value = lambda_min_val;
            }

            const detectorParams = {
                reciprocalMatrix: reciprocalMatrix.clone(),
                bravaisType: bravaisLatticeOptions[bravaisKey].type,
                lambda_min: lambda_min_val,
                lambda_max: lambda_max_val,
                dist: dist_val,
                angle_deg: angle_deg_val
            };
           

            
            return getSimulatedSpots(rotX_deg, rotY_deg, rotZ_deg, detectorParams, HKL_RANGE);
        }


        // This function implements the general detector plane logic
        function getSimulatedSpots(rotX_deg, rotY_deg, rotZ_deg, detectorParams, hklRangeVal) {
            let spots = [];
            let { // Use 'let' to allow modification
                reciprocalMatrix,
                bravaisType,
                lambda_min,
                lambda_max,
                dist,
                angle_deg // <-- We now get angle_deg
            } = detectorParams;
        
              // --- 1. Set up Detector Plane ---
            const phi_D_rad = THREE.MathUtils.degToRad(angle_deg);
            const cosPhi = Math.cos(phi_D_rad);
            const sinPhi = Math.sin(phi_D_rad);
        
            // Physical normal vector of the detector plane
            const detectorNormal = new THREE.Vector3(cosPhi, sinPhi, 0);
            
            // The detector's horizontal "u-axis"
            const u_axis = new THREE.Vector3(-sinPhi, cosPhi, 0);
        
            // --- 2. Set up Simulation Parameters ---
            const hkl_range = {
                h_min: -hklRangeVal, h_max: hklRangeVal,
                k_min: -hklRangeVal, k_max: hklRangeVal,
                l_min: -hklRangeVal, l_max: hklRangeVal
            };
        
            const gonioEuler = new THREE.Euler(
                THREE.MathUtils.degToRad(rotX_deg),
                THREE.MathUtils.degToRad(rotY_deg),
                THREE.MathUtils.degToRad(rotZ_deg),
                'XYZ'
            );
        
            const k_min = 1 / lambda_max;
            const k_max = 1 / lambda_min;
        
            // --- 3. Setup Re-usable THREE objects ---
            const intersectionPoint = new THREE.Vector3();
            const k_in_vec = new THREE.Vector3(); // Will be set in loop
            const k_f_vec = new THREE.Vector3(); // Diffracted beam
            const g_vec = new THREE.Vector3(); // Reciprocal lattice vector
        
            for (let h = hkl_range.h_min; h <= hkl_range.h_max; h++) {
            for (let k = hkl_range.k_min; k <= hkl_range.k_max; k++) {
                for (let l = hkl_range.l_min; l <= hkl_range.l_max; l++) {
                    if ((h === 0 && k === 0 && l === 0) || !isReflectionAllowed(h, k, l, bravaisType))
                        continue;
        
                    // Calculate G-vector in rotated lab frame
                    g_vec.set(h, k, l).applyMatrix3(reciprocalMatrix);
                    g_vec.applyMatrix4(baseOrientationMatrix);
                    g_vec.applyEuler(gonioEuler);
        
                    const g_sq = g_vec.lengthSq();
                    const g_x = g_vec.x; // G-vector component along incident beam
                   
                    // Laue condition: k = -|g|^2 / (2 * g_x)
                    // k must be positive, so g_x must be negative.
                    if (g_x >= -1e-6) continue;
        
                    const k_diff = -g_sq / (2 * g_x);
                    if (k_diff < k_min || k_diff > k_max) continue;
        
                    // k_in = (k, 0, 0)
                    k_in_vec.set(k_diff, 0, 0);
                    
                    // k_f = k_in + g
                    k_f_vec.addVectors(k_in_vec, g_vec);
              
                    
                    const kf_dot_normal = k_f_vec.dot(detectorNormal);

             
                    if (kf_dot_normal < 1e-6) {
                        continue; // Beam is parallel or points away from the detector
                    }

                    // We have a valid hit. Calculate intersection.
                    const t = dist / kf_dot_normal;
                    intersectionPoint.copy(k_f_vec).multiplyScalar(t);

                    // We need to find the (u,v) coordinates
                    // v-coordinate is the Z component
                    const v = intersectionPoint.z;
                    const u = intersectionPoint.dot(u_axis);

                    spots.push({
                        x_2d: u,  // This is our new 'u', version "analytiqué" modifiée
                        y_2d: v,  // This is our new 'v'
                        h, k, l
                    });
                }
            }
        }
            return spots;
        }
    


        function updateVisualization() {
            detectorSpots = [];
            highlightedSpot = null;
            
            const rotX_deg = parseFloat(document.getElementById('rotX').value) || 0;
            const rotY_deg = parseFloat(document.getElementById('rotY').value) || 0;
            const rotZ_deg = parseFloat(document.getElementById('rotZ').value) || 0;


            // We must check for NaN, because parseFloat(0) is 0, which is falsy and would trigger the || 180.
            let detectorAngle = parseFloat(document.getElementById('detectorAngle').value);
            if (isNaN(detectorAngle)) {
                detectorAngle = 180;
            }

            // 2. PASS the angle as an argument here
            detectorSpots = generateSpotsForOrientation(rotX_deg, rotY_deg, rotZ_deg, detectorAngle); 
            
            redrawDetector();
        }

        //  getScatteringVector function 
        function getScatteringVector(u_mm, v_mm, D_mm, angle_deg) {
            
  
            const phi_D_rad = THREE.MathUtils.degToRad(angle_deg);
            const cosPhi = Math.cos(phi_D_rad);
            const sinPhi = Math.sin(phi_D_rad);

            // Reconstruct the detector's coordinate system in 3D
            const detectorNormal = new THREE.Vector3(cosPhi, sinPhi, 0);
            const u_axis = new THREE.Vector3(-sinPhi, cosPhi, 0); // Must match getSimulatedSpots
            const v_axis = new THREE.Vector3(0, 0, 1);

            // Center of the detector plane in 3D
            const detectorCenter = detectorNormal.clone().multiplyScalar(D_mm);
            
            // 3D position of the spot on the detector plane
            const detectorPos = new THREE.Vector3()
                .add(detectorCenter)
                .addScaledVector(u_axis, u_mm)
                .addScaledVector(v_axis, v_mm);

            // k_in is ALWAYS from +X
            const k_in = new THREE.Vector3(1, 0, 0); 
            
            // k_out is the normalized vector from origin to the detector spot
            const k_out = detectorPos.clone().normalize();
            
            // g = k_out - k_in
            const g = new THREE.Vector3().subVectors(k_out, k_in);
            return g.normalize();
        }


        function kabschRotation(pointsA, pointsB) {
            if (pointsA.length !== pointsB.length || pointsA.length < 2) return null;
            
            if (pointsA.length === 2) {
                const a1 = pointsA[0].clone().normalize();
                const a2_raw = pointsA[1].clone();
                const a2_perp = new THREE.Vector3().subVectors(a2_raw, a1.clone().multiplyScalar(a1.dot(a2_raw))).normalize();
                const a3 = new THREE.Vector3().crossVectors(a1, a2_perp).normalize();
                
                const b1 = pointsB[0].clone().normalize();
                const b2_raw = pointsB[1].clone();
                const b2_perp = new THREE.Vector3().subVectors(b2_raw, b1.clone().multiplyScalar(b1.dot(b2_raw))).normalize();
                const b3 = new THREE.Vector3().crossVectors(b1, b2_perp).normalize();
                
                const matA = new THREE.Matrix4().makeBasis(a1, a2_perp, a3);
                const matB = new THREE.Matrix4().makeBasis(b1, b2_perp, b3);
                
                const matA_inv = new THREE.Matrix4().copy(matA).invert();
                return new THREE.Matrix4().multiplyMatrices(matB, matA_inv);
            }
            
            const centroidA = new THREE.Vector3();
            const centroidB = new THREE.Vector3();
            for (let i = 0; i < pointsA.length; i++) {
                centroidA.add(pointsA[i]);
                centroidB.add(pointsB[i]);
            }
            centroidA.divideScalar(pointsA.length);
            centroidB.divideScalar(pointsA.length);
            
            const H = new THREE.Matrix3();
            H.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
            
            for (let i = 0; i < pointsA.length; i++) {
                const a = new THREE.Vector3().subVectors(pointsA[i], centroidA);
                const b = new THREE.Vector3().subVectors(pointsB[i], centroidB);
                H.elements[0] += a.x * b.x; H.elements[1] += a.x * b.y; H.elements[2] += a.x * b.z;
                H.elements[3] += a.y * b.x; H.elements[4] += a.y * b.y; H.elements[5] += a.y * b.z;
                H.elements[6] += a.z * b.x; H.elements[7] += a.z * b.y; H.elements[8] += a.z * b.z;
            }
            
            const h = H.elements;
            const col1 = new THREE.Vector3(h[0], h[3], h[6]).normalize();
            const col2_raw = new THREE.Vector3(h[1], h[4], h[7]);
            const col2 = new THREE.Vector3().subVectors(col2_raw, col1.clone().multiplyScalar(col1.dot(col2_raw))).normalize();
            const col3 = new THREE.Vector3().crossVectors(col1, col2).normalize();
            
            const R = new THREE.Matrix4();
            R.makeBasis(col1, col2, col3);
            return R;
        }


    
        async function findOrientation() {

            const searchBtn = document.getElementById('searchOrientBtn');

            
            // 1. Get experimental parameters
            const D = getValidatedNumericInput('detectorDistance', 1, 1000, 36);
            let angle_deg = getValidatedNumericInput('detectorAngle', 0, 180, 180);
           
            const expSpots_mm = experimentalSpots.map(p => ({
                        x: (p.raw_x - imageCenter.raw_x) / pixels_per_mm_x, // This is U
                        y: -(p.raw_y - imageCenter.raw_y) / pixels_per_mm_y  // This is V
                    }));

            const params = getLatticeParameters();
            if (Object.values(params).some(isNaN) || !updateReciprocalMatrix(params)) {
                statusInfoDiv.textContent = 'Error: Invalid lattice parameters.';
                searchBtn.disabled = false;
                searchBtn.textContent = 'Search Orientation';
                document.body.style.cursor = 'default';
                return;
            }

            const bravaisKey = document.getElementById('bravaisLattice').value;
            const bravaisType = bravaisLatticeOptions[bravaisKey].type;
            
            // 2. Calculate experimental scattering vectors (g-vectors)
            statusInfoDiv.textContent = 'Calculating experimental scattering vectors...';
            await new Promise(resolve => setTimeout(resolve, 10));
            const expGVectors = expSpots_mm.map(spot => getScatteringVector(spot.x, spot.y, D, angle_deg)); // <-- Pass angle
            
            // 3. Generate reciprocal lattice library
            statusInfoDiv.textContent = 'Generating reciprocal lattice library...';
            await new Promise(resolve => setTimeout(resolve, 10));
            
            const HKL_SEARCH_RANGE = 2; // ONLY lowest indices: ±2
            const hklLibrary = [];
            for (let h = -HKL_SEARCH_RANGE; h <= HKL_SEARCH_RANGE; h++) {
                for (let k = -HKL_SEARCH_RANGE; k <= HKL_SEARCH_RANGE; k++) {
                    for (let l = -HKL_SEARCH_RANGE; l <= HKL_SEARCH_RANGE; l++) {
                        if (h === 0 && k === 0 && l === 0) continue;
                        if (!isReflectionAllowed(h, k, l, bravaisType)) continue;
                        
                        const g_vec = new THREE.Vector3(h, k, l).applyMatrix3(reciprocalMatrix);
                        g_vec.normalize();
                        const hkl_sum = Math.abs(h) + Math.abs(k) + Math.abs(l);
                        hklLibrary.push({ h, k, l, g: g_vec, hkl_sum: hkl_sum, priority: 1.0 / (h*h + k*k + l*l) });
                    }
                }
            }
            hklLibrary.sort((a, b) => a.hkl_sum - b.hkl_sum);
            if (hklLibrary.length < 2) {
                statusInfoDiv.textContent = 'Not enough valid reflections generated.';
                searchBtn.disabled = false;
                searchBtn.textContent = 'Search Orientation';
                document.body.style.cursor = 'default';
                return;
            }
            
            // 4. Match pairs
            statusInfoDiv.textContent = 'Matching experimental pairs to hkl pairs...';
            await new Promise(resolve => setTimeout(resolve, 10));
            
            const angleTolerance = THREE.MathUtils.degToRad(5.0);
            const candidateOrientations = [];
            for (let i = 0; i < expGVectors.length; i++) {
                for (let j = i + 1; j < expGVectors.length; j++) {
                    const g_exp_i = expGVectors[i];
                    const g_exp_j = expGVectors[j];
                    const dot_exp = Math.max(-1, Math.min(1, g_exp_i.dot(g_exp_j)));
                    const angle_exp = Math.acos(dot_exp);
                    
                    for (let m = 0; m < hklLibrary.length; m++) {
                        for (let n = m + 1; n < hklLibrary.length; n++) {
                            const hkl_m = hklLibrary[m];
                            const hkl_n = hklLibrary[n];
                            const dot_sim = Math.max(-1, Math.min(1, hkl_m.g.dot(hkl_n.g)));
                            const angle_sim = Math.acos(dot_sim);
                            
                            if (Math.abs(angle_exp - angle_sim) < angleTolerance) {
                                candidateOrientations.push({
                                    exp_indices: [i, j], hkl_indices: [m, n],
                                    priority: hkl_m.priority + hkl_n.priority,
                                    angle_exp: angle_exp, angle_sim: angle_sim
                                });
                            }
                        }
                    }
                }
            }
            if (candidateOrientations.length === 0) {
                statusInfoDiv.textContent = 'No angle matches found.';
                searchBtn.disabled = false;
                searchBtn.textContent = 'Search Orientation';
                document.body.style.cursor = 'default';
                return;
            }
            candidateOrientations.sort((a, b) => b.priority - a.priority);
            
            // 5. Test candidates
            statusInfoDiv.textContent = `Testing ${Math.min(candidateOrientations.length, 100)} orientation candidates...`;
            await new Promise(resolve => setTimeout(resolve, 10));
            
            const solutions = [];
            const maxCandidates = Math.min(100, candidateOrientations.length);
       
            let lambda_min_val = getValidatedNumericInput('lambda_min', 0.1, 20.0, 0.2);
            let lambda_max_val = getValidatedNumericInput('lambda_max', 0.1, 20.0, 3.0);
            
            // Cross-check: ensure min is less than max
            if (lambda_min_val >= lambda_max_val) {
                lambda_min_val = lambda_max_val - 0.1;
                if (lambda_min_val < 0.1) lambda_min_val = 0.1;
                document.getElementById('lambda_min').value = lambda_min_val;
                const min_slider = document.getElementById('lambda_min_slider');
                if (min_slider) min_slider.value = lambda_min_val;
            }

            const detectorParams = {
                reciprocalMatrix: reciprocalMatrix.clone(),
                bravaisType: bravaisType,
                lambda_min: lambda_min_val,
                lambda_max: lambda_max_val,
                dist: D, // D is already validated
                angle_deg: angle_deg // angle_deg is already validated
            };

            
            for (let c = 0; c < maxCandidates; c++) {
                const cand = candidateOrientations[c];
                const expVecs = [ expGVectors[cand.exp_indices[0]], expGVectors[cand.exp_indices[1]] ];
                const simVecs = [ hklLibrary[cand.hkl_indices[0]].g, hklLibrary[cand.hkl_indices[1]].g ];
                
                const rotMatrix = kabschRotation(simVecs, expVecs);
                if (!rotMatrix) continue;
                
                const euler = new THREE.Euler().setFromRotationMatrix(rotMatrix, 'XYZ');
                
                baseOrientationMatrix.makeRotationFromEuler(euler);
                const simSpots = getSimulatedSpots(0, 0, 0, detectorParams, HKL_RANGE);
                
                // Score this orientation
                const tolerance_mm = 4.0;
                let matches = 0;
                let sumSquaredError = 0;
                for (const expSpot of expSpots_mm) {
                    let minDist = Infinity;
                    for (const simSpot of simSpots) {
                        const dist = Math.sqrt((expSpot.x - simSpot.x_2d)**2 + (expSpot.y - simSpot.y_2d)**2);
                        if (dist < minDist) minDist = dist;
                    }
                    if (minDist < tolerance_mm) {
                        matches++;
                        sumSquaredError += minDist * minDist;
                    }
                }
                
                const minRequiredMatches = Math.max(2, Math.ceil(expSpots_mm.length / 2));
                if (matches >= minRequiredMatches) {
                    const rmsError = Math.sqrt(sumSquaredError / matches);
                    const coverage = matches / expSpots_mm.length;
                    const coveragePenalty = Math.pow(2.0 - coverage, 2);
                    const score = rmsError * coveragePenalty;
                    
                    solutions.push({
                        euler: { 
                            rotX: THREE.MathUtils.radToDeg(euler.x), 
                            rotY: THREE.MathUtils.radToDeg(euler.y), 
                            rotZ: THREE.MathUtils.radToDeg(euler.z) 
                        },
                        score: score, matches: matches,
                        rmsError: rmsError, coverage: coverage
                    });
                }
            }
            
            baseOrientationMatrix.identity();
            
            solutions.sort((a, b) => a.score - b.score);
            orientationSolutions = solutions.slice(0, 20);
            
            updateSolutionsTab();
            
            if (orientationSolutions.length > 0) {
                const best = orientationSolutions[0];
                // 1. Get the best solution's Euler angles
                const euler = new THREE.Euler(
                    THREE.MathUtils.degToRad(best.euler.rotX),
                    THREE.MathUtils.degToRad(best.euler.rotY),
                    THREE.MathUtils.degToRad(best.euler.rotZ),
                    'XYZ'
                );
                // 2. Store this as the new "Base Orientation"
                baseOrientationMatrix.makeRotationFromEuler(euler);

                // 3. DO NOT change the sliders. The goniometer sliders stay at (0,0,0).
                
                // 4. Update the visualization. This will re-run the simulation 
                //    using the new baseOrientationMatrix and the current (0,0,0) slider values.
                updateVisualization();
                
                // Highlight the first solution in the Solutions tab
                document.querySelectorAll('.solution-item').forEach((item, i) => {
                    item.classList.toggle('selected', i === 0);
                });

                // Update status messages
                fomInfoDiv.innerHTML = `Best: ${best.matches}/${expSpots_mm.length} matched (${(best.coverage*100).toFixed(0)}%), RMS=${best.rmsError.toFixed(2)}mm`;
                fomInfoDiv.style.display = 'block';
                statusInfoDiv.textContent = `Found ${orientationSolutions.length} solutions. Displaying best match at (0,0,0) goniometer.`;
                
            } else {
                fomInfoDiv.innerHTML = 'No valid orientation found. Check console for diagnostics.';
                fomInfoDiv.style.display = 'block';
                statusInfoDiv.textContent = 'Search failed. See console for details.';
            }
            
            searchBtn.disabled = false;
            searchBtn.textContent = 'Search Orientation';
            document.body.style.cursor = 'default';
        }

        
        function updateSolutionsTab() {
            solutionsListDiv.innerHTML = '';
            if (orientationSolutions.length === 0) {
                solutionsListDiv.innerHTML = '<div class="text-gray-600">No solutions found.</div>';
                return;
            }
            
            orientationSolutions.forEach((sol, index) => {
                const item = document.createElement('div');
                item.className = 'solution-item cursor-pointer';
                item.id = `solution-item-${index}`;
                
                item.innerHTML = `
                    <div class="flex justify-between items-center w-full">
                        <div>
                            <div class="font-bold">Solution ${index + 1} (Score: ${sol.score.toFixed(4)})</div>
                            <div class="text-sm text-gray-700">
                                X: ${sol.euler.rotX.toFixed(2)}°, 
                                Y: ${sol.euler.rotY.toFixed(2)}°, 
                                Z: ${sol.euler.rotZ.toFixed(2)}°
                            </div>
                        </div>
                        
                        <button class="btn-remove-solution" 
                                style="width: 24px; height: 24px; font-size: 1em; font-weight: bold;
                                       line-height: 1; display: flex; align-items: center; justify-content: center; 
                                       background-color: var(--error-red); color: white; border-radius: 4px; 
                                       border: none; cursor: pointer; margin-left: 10px; flex-shrink: 0;">
                            x
                        </button>
                    </div>
                `;
                
                item.addEventListener('click', () => { 
                    selectSolution(index);
                });
                
                item.querySelector('.btn-remove-solution').addEventListener('click', (e) => {
                    e.stopPropagation();
                    orientationSolutions.splice(index, 1);
                    updateSolutionsTab();
                    fomInfoDiv.style.display = 'none';
                });
                
                solutionsListDiv.appendChild(item);
            });
        }
        

        // This function now sets the baseOrientationMatrix and resets goniometer
        function selectSolution(index) {
            const sol = orientationSolutions[index];
            if (!sol) return;

            // --- NEW: Set the base orientation to this solution ---
            const euler = new THREE.Euler(
                THREE.MathUtils.degToRad(sol.euler.rotX),
                THREE.MathUtils.degToRad(sol.euler.rotY),
                THREE.MathUtils.degToRad(sol.euler.rotZ),
                'XYZ'
            );
            baseOrientationMatrix.makeRotationFromEuler(euler);
            
            // --- IMPORTANT: Reset goniometer sliders to 0 ---
            // This assumes the user wants to see the *raw* solution
            // without any goniometer rotation applied.
            document.getElementById('rotX').value = 0;
            document.getElementById('rotY').value = 0;
            document.getElementById('rotZ').value = 0;
            document.getElementById('rotX_slider').value = 0;
            document.getElementById('rotY_slider').value = 0;
            document.getElementById('rotZ_slider').value = 0;

            // Update the visualization with the new base + 0 goniometer
            updateVisualization();
            
            // Highlight in solutions list
            document.querySelectorAll('.solution-item').forEach((item, i) => {
                item.classList.toggle('selected', i === index);
            });
            
            fomInfoDiv.innerHTML = `Displaying Solution ${index + 1} (Score: ${sol.score.toFixed(4)})`;
            fomInfoDiv.style.display = 'block';
        }
  
        // This function now calculates the required goniometer angles
        // relative to the current base orientation.
        function orientToHKL() {
            orientStatusDiv.textContent = 'Calculating...';

            // 1. Get h, k, l inputs
            const h = parseInt(document.getElementById('orient_h').value);
            const k = parseInt(document.getElementById('orient_k').value);
            const l = parseInt(document.getElementById('orient_l').value);
            if (isNaN(h) || isNaN(k) || isNaN(l) || (h===0 && k===0 && l===0)) {
                orientStatusDiv.textContent = 'Error: Invalid (h,k,l).';
                return;
            }

            // 2. Get lattice parameters
            const params = getLatticeParameters();
            if (Object.values(params).some(isNaN) || !updateReciprocalMatrix(params)) {
                orientStatusDiv.textContent = 'Error: Invalid lattice parameters.';
                return;
            }
            
            // 3. Calculate unrotated g-vector
            const g_unrotated = new THREE.Vector3(h, k, l).applyMatrix3(reciprocalMatrix);
            const g_length = g_unrotated.length();
            if (g_length < 1e-9) {
                orientStatusDiv.textContent = 'Error: Reciprocal vector has zero length.';
                return;
            }
            const vFrom = g_unrotated.clone().normalize();

            // 4. Define target vector
            // We want to align the (h,k,l) vector ANTI-PARALLEL to the
            // incident beam (which is +X). So, the target is -X.
            // This is the condition for 180-degree back-scattering.
            const vTo = new THREE.Vector3(-1, 0, 0); 

            // 5. Calculate the TOTAL target rotation (R_target)
            const targetQuaternion = new THREE.Quaternion();
            if (vFrom.dot(vTo) < -0.999999) {
                let perpAxis = new THREE.Vector3(0, 1, 0);
                if (Math.abs(vFrom.y) > 0.99) perpAxis.set(1, 0, 0);
                targetQuaternion.setFromAxisAngle(perpAxis, Math.PI);
            } else {
                targetQuaternion.setFromUnitVectors(vFrom, vTo);
            }
            const targetMatrix = new THREE.Matrix4().makeRotationFromQuaternion(targetQuaternion);

            // 6. 
            // We want to find R_gonio such that: R_target = R_gonio * U_base
            // Therefore: R_gonio = R_target * U_base_inverse
            
            const baseInverseMatrix = new THREE.Matrix4().copy(baseOrientationMatrix).invert();
            const gonioMatrix = new THREE.Matrix4().multiplyMatrices(targetMatrix, baseInverseMatrix);

            // 7. Extract Euler angles from the calculated goniometer matrix
            const gonioEuler = new THREE.Euler().setFromRotationMatrix(gonioMatrix, 'XYZ');
            const rotX_deg = THREE.MathUtils.radToDeg(gonioEuler.x);
            const rotY_deg = THREE.MathUtils.radToDeg(gonioEuler.y);
            const rotZ_deg = THREE.MathUtils.radToDeg(gonioEuler.z);
            
            // 8. Set UI controls
            // Set the read-only fields in the Orient tab
            document.getElementById('orient_X_out').value = rotX_deg.toFixed(2);
            document.getElementById('orient_Y_out').value = rotY_deg.toFixed(2);
            document.getElementById('orient_Z_out').value = rotZ_deg.toFixed(2);
            
            // Set the main goniometer sliders (now on the "Set" tab)
            document.getElementById('rotX').value = rotX_deg.toFixed(2);
            document.getElementById('rotY').value = rotY_deg.toFixed(2);
            document.getElementById('rotZ').value = rotZ_deg.toFixed(2);
            document.getElementById('rotX_slider').value = rotX_deg;
            document.getElementById('rotY_slider').value = rotY_deg;
            document.getElementById('rotZ_slider').value = rotZ_deg;

            // 9. Update visualization
            updateVisualization();



            // 10. Update status message
            const bravaisKey = document.getElementById('bravaisLattice').value;
            const bravaisType = bravaisLatticeOptions[bravaisKey].type;

            // --- MODIFIED: Validate inputs ---
            let lambda_min = getValidatedNumericInput('lambda_min', 0.1, 20.0, 0.2);
            let lambda_max = getValidatedNumericInput('lambda_max', 0.1, 20.0, 3.0);
            
            // Cross-check: ensure min is less than max
            if (lambda_min >= lambda_max) {
                lambda_min = lambda_max - 0.1;
                if (lambda_min < 0.1) lambda_min = 0.1;
            }

            const angle_deg = getValidatedNumericInput('detectorAngle', 0, 180, 180);
            

            let statusMsg = `Goniometer set for ${angle_deg.toFixed(1)}° detector. `;

           // Check if the spot is visible
            // Required lambda for 180-deg backscatter: 2 * d = lambda -> lambda = 2 / |g|
            const required_lambda = 2 / g_length;
            if (!isReflectionAllowed(h, k, l, bravaisType)) {
                statusMsg = `Warning: (${h},${k},${l}) is forbidden. `;
            } else if (required_lambda < lambda_min || required_lambda > lambda_max) {
                statusMsg += `Note: Spot may not appear. Required λ (${required_lambda.toFixed(3)} Å) is outside range [${lambda_min}, ${lambda_max}].`;
            } else {
                statusMsg += `Required λ: ${required_lambda.toFixed(3)} Å.`;
            }
            orientStatusDiv.textContent = statusMsg;
        }


        async function generateReport() {
            const reportButton = document.getElementById('generateReportBtn');
            reportButton.textContent = 'Generating...';
            reportButton.disabled = true;
            document.body.style.cursor = 'wait';
            
            try {
                const { jsPDF } = window.jspdf;
                const doc = new jsPDF({
                    orientation: 'p',
                    unit: 'mm',
                    format: 'a4'
                });

                const margin = 15;
                let yPos = 20;
                const pdfWidth = doc.internal.pageSize.getWidth();
                const col1X = margin;
                const col2X = margin + 85;
                const paramLabelWidth = 45;

                const FONT = { TITLE: 'helvetica', LABEL: 'helvetica', DATA: 'courier' };
                const SIZE = { TITLE: 18, H1: 14, H2: 12, BODY: 9, SMALL: 8 };

                const addParamRow = (label, value) => {
                    if (yPos > 270) { doc.addPage(); yPos = 20; }
                    doc.setFont(FONT.LABEL, 'normal').setFontSize(SIZE.BODY);
                    doc.text(label, col1X, yPos);
                    doc.setFont(FONT.DATA, 'normal').setFontSize(SIZE.BODY);
                    doc.text(String(value), col1X + paramLabelWidth, yPos);
                    yPos += 5;
                };
                const addParamRowSplit = (label1, value1, label2, value2) => {
                    if (yPos > 270) { doc.addPage(); yPos = 20; }
                    doc.setFont(FONT.LABEL, 'normal').setFontSize(SIZE.BODY);
                    doc.text(label1, col1X, yPos);
                    doc.setFont(FONT.DATA, 'normal').setFontSize(SIZE.BODY);
                    doc.text(String(value1), col1X + paramLabelWidth, yPos);
                    
                    doc.setFont(FONT.LABEL, 'normal').setFontSize(SIZE.BODY);
                    doc.text(label2, col2X, yPos);
                    doc.setFont(FONT.DATA, 'normal').setFontSize(SIZE.BODY);
                    doc.text(String(value2), col2X + paramLabelWidth, yPos);
                    yPos += 5;
                };
                const addHeader = (text) => {
                    if (yPos > 260) { doc.addPage(); yPos = 20; }
                    yPos += 4; // Space before header
                    doc.setFont(FONT.LABEL, 'bold').setFontSize(SIZE.H1);
                    doc.text(text, margin, yPos);
                    yPos += 8;
                };

                const now = new Date();
                const timestamp = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}-${String(now.getDate()).padStart(2, '0')} ${String(now.getHours()).padStart(2, '0')}:${String(now.getMinutes()).padStart(2, '0')}`;
                
                doc.setFont(FONT.TITLE, 'bold').setFontSize(SIZE.TITLE);
                doc.text('Laue Indexing Report', pdfWidth / 2, yPos, { align: 'center' });
                yPos += 10;
                
                addParamRow('URL:', window.location.href);
                addParamRow('Version:', '3.0 (General Detector), November 1, 2025');
                yPos += 5;
              
                addParamRow('Generated:', timestamp);
                const fileName = document.getElementById('imageLoader').files[0]?.name || 'N/A (simulation)';
                addParamRow('Image File:', fileName);
                yPos += 5;
                
                addHeader('Detector View');
                const compositeCanvas = document.createElement('canvas');
                const w = detectorCanvas.width;
                const h = detectorCanvas.height;
                compositeCanvas.width = w;
                compositeCanvas.height = h;
                const compositeCtx = compositeCanvas.getContext('2d');
                compositeCtx.fillStyle = '#ffffff';
                compositeCtx.fillRect(0, 0, w, h);
                compositeCtx.drawImage(experimentCanvas, 0, 0, w, h);
                compositeCtx.drawImage(detectorCanvas, 0, 0, w, h);
                const imgData = compositeCanvas.toDataURL('image/png');
              
                const imgProps = doc.getImageProperties(imgData);
                const availableWidth = pdfWidth - 2 * margin;
                let imgHeight = (imgProps.height * availableWidth) / imgProps.width;
                if (yPos + imgHeight > 280) { doc.addPage(); yPos = 20; }
                
                doc.addImage(imgData, 'PNG', margin, yPos, availableWidth, imgHeight);
                yPos += imgHeight + 10;

                addHeader('Simulation Parameters');
                const lattice = getLatticeParameters();
                const latticeKey = document.getElementById('bravaisLattice').value;
                addParamRow('Lattice:', latticeKey);
                
                addParamRowSplit('a (Å):', lattice.a.toFixed(4), 'alpha (°):', lattice.alpha.toFixed(2));
                addParamRowSplit('b (Å):', lattice.b.toFixed(4), 'beta (°):', lattice.beta.toFixed(2));
                addParamRowSplit('c (Å):', lattice.c.toFixed(4), 'gamma (°):', lattice.gamma.toFixed(2));
                
                yPos += 5;
                addParamRow('Wavelength min (Å):', document.getElementById('lambda_min').value);
                addParamRow('Wavelength max (Å):', document.getElementById('lambda_max').value);
                
                yPos += 5;
                addParamRow('Detector Angle (°):', document.getElementById('detectorAngle').value);
                addParamRow('Distance (mm):', document.getElementById('detectorDistance').value);
                
                yPos += 5;
                addParamRow('Goniometer X (°):', document.getElementById('rotX').value);
                addParamRow('Goniometer Y (°):', document.getElementById('rotY').value);
                addParamRow('Goniometer Z (°):', document.getElementById('rotZ').value);
                
                // --- NEW: Add Orientation Target Section ---
                const orientX_out = document.getElementById('orient_X_out').value;
                const orientY_out = document.getElementById('orient_Y_out').value;
                const orientZ_out = document.getElementById('orient_Z_out').value;
        
                if (orientX_out || orientY_out || orientZ_out) {
                    addHeader('Orientation Target');
                    const h = document.getElementById('orient_h').value;
                    const k = document.getElementById('orient_k').value;
                    const l = document.getElementById('orient_l').value;
                    addParamRow('Target (h,k,l):', `(${h}, ${k}, ${l})`);
                    yPos += 5;
                    addParamRow('Required Goniometer X (°):', orientX_out);
                    addParamRow('Required Goniometer Y (°):', orientY_out);
                    addParamRow('Required Goniometer Z (°):', orientZ_out);
                }
                // --- END NEW SECTION ---
                
                const scale_valid = pixels_per_mm_x > 0 && pixels_per_mm_y > 0;
                if (imageCenter) {
                    addHeader('Analysis Parameters');
                    addParamRow('Center (px):', `x: ${imageCenter.raw_x.toFixed(2)}, y: ${imageCenter.raw_y.toFixed(2)}`);
                    
                    if (scalePoint) {
                        addParamRow('Scale Point (px):', `x: ${scalePoint.raw_x.toFixed(2)}, y: ${scalePoint.raw_y.toFixed(2)}`);
                        const scale_u_mm = parseFloat(document.getElementById('scalePointX_mm').value);
                        const scale_v_mm = parseFloat(document.getElementById('scalePointY_mm').value);
                        addParamRow('Scale Point (mm):', `U: ${scale_u_mm.toFixed(3)}, V: ${scale_v_mm.toFixed(3)}`);
                    }
                    
                    if (scale_valid) {
                        addParamRow('Scale (px/mm U):', pixels_per_mm_x.toFixed(4));
                        addParamRow('Scale (px/mm V):', pixels_per_mm_y.toFixed(4));
                    } else {
                        addParamRow('Scale (px/mm):', 'Not set or invalid.');
                    }
                }
              
                if (experimentalSpots.length > 0 && scale_valid) { 
                    addHeader('Experimental Peaks');
                    
                    doc.setFont(FONT.DATA, 'bold').setFontSize(SIZE.SMALL);
                    doc.text('#', col1X, yPos);
                    doc.text('U (mm)', col1X + 10, yPos);
                    doc.text('V (mm)', col1X + 35, yPos);
                    doc.text('Raw X (px)', col1X + 60, yPos);
                    doc.text('Raw Y (px)', col1X + 85, yPos);
                    yPos += 5;
                    doc.setFont(FONT.DATA, 'normal').setFontSize(SIZE.SMALL);
                    
                    for (let i = 0; i < experimentalSpots.length; i++) {
                        if (yPos > 280) { 
                            doc.addPage(); yPos = 20; 
                            doc.setFont(FONT.DATA, 'bold').setFontSize(SIZE.SMALL);
                            doc.text('#', col1X, yPos);
                            doc.text('U (mm)', col1X + 10, yPos);
                            doc.text('V (mm)', col1X + 35, yPos);
                            doc.text('Raw X (px)', col1X + 60, yPos);
                            doc.text('Raw Y (px)', col1X + 85, yPos);
                            yPos += 5;
                            doc.setFont(FONT.DATA, 'normal').setFontSize(SIZE.SMALL);
                        }
                        const spot = experimentalSpots[i];
                        const u_mm = (spot.raw_x - imageCenter.raw_x) / pixels_per_mm_x;
                        const v_mm = -(spot.raw_y - imageCenter.raw_y) / pixels_per_mm_y;
                        doc.text(String(i + 1), col1X, yPos);
                        doc.text(u_mm.toFixed(3), col1X + 10, yPos);
                        doc.text(v_mm.toFixed(3), col1X + 35, yPos);
                        doc.text(spot.raw_x.toFixed(2), col1X + 60, yPos);
                        doc.text(spot.raw_y.toFixed(2), col1X + 85, yPos);
                        yPos += 4;
                    }
                }

                if (orientationSolutions.length > 0) {
                    
                    // --- REORDERED: This "Best Solution Details" (peak list) now comes FIRST ---
                    const bestSol = orientationSolutions[0];
                    addHeader(`Best Solution (Solution 1) Details`);
                    
                    const D = parseFloat(document.getElementById('detectorDistance').value);
                    const angle_deg = parseFloat(document.getElementById('detectorAngle').value);
                    const bravaisKey = document.getElementById('bravaisLattice').value;
                    const detectorParams = {
                        reciprocalMatrix: reciprocalMatrix.clone(),
                        bravaisType: bravaisLatticeOptions[bravaisKey].type,
                        lambda_min: parseFloat(document.getElementById('lambda_min').value),
                        lambda_max: parseFloat(document.getElementById('lambda_max').value),
                        dist: D,
                        angle_deg: angle_deg // <-- NEW
                    };
                    
                    const expSpots_mm = experimentalSpots.map((p, idx) => ({
                        x: (p.raw_x - imageCenter.raw_x) / pixels_per_mm_x, // U
                        y: -(p.raw_y - imageCenter.raw_y) / pixels_per_mm_y, // V
                        original_index: idx + 1
                    }));
                    
                    // --- GET SIM SPOTS FOR REPORT ---
                    const tempEuler = new THREE.Euler(
                        THREE.MathUtils.degToRad(bestSol.euler.rotX),
                        THREE.MathUtils.degToRad(bestSol.euler.rotY),
                        THREE.MathUtils.degToRad(bestSol.euler.rotZ), 'XYZ'
                    );
                    const tempBase = new THREE.Matrix4().makeRotationFromEuler(tempEuler);
                    
                    const gonioX = parseFloat(document.getElementById('rotX').value);
                    const gonioY = parseFloat(document.getElementById('rotY').value);
                    const gonioZ = parseFloat(document.getElementById('rotZ').value);
                    
                    const oldBase = baseOrientationMatrix.clone();
                    baseOrientationMatrix.copy(tempBase); 
                    const simSpots = getSimulatedSpots(gonioX, gonioY, gonioZ, detectorParams, HKL_RANGE);
                    baseOrientationMatrix.copy(oldBase); // Restore
                    // --- END ---
                    
                    const tolerance_mm = 4.0;
                    const matches = [];
                    
                    for (const expSpot of expSpots_mm) {
                        let bestMatch = null;
                        let minDist = Infinity;
                        for (const simSpot of simSpots) {
                            const dist = Math.sqrt((expSpot.x - simSpot.x_2d)**2 + (expSpot.y - simSpot.y_2d)**2);
                            let isNewBest = false;
                            if (dist < (minDist - 1e-6)) {
                                isNewBest = true;
                            } else if (Math.abs(dist - minDist) < 1e-6) {
                                if (bestMatch) {
                                    const current_hkl_sq = bestMatch.h**2 + bestMatch.k**2 + bestMatch.l**2;
                                    const new_hkl_sq = simSpot.h**2 + simSpot.k**2 + simSpot.l**2;
                                    if (new_hkl_sq < current_hkl_sq) isNewBest = true;
                                } else {
                                    isNewBest = true;
                                }
                            }
                            if (isNewBest) {
                                minDist = dist;
                                bestMatch = simSpot;
                            }
                        }
                        
                        if (bestMatch && minDist <= tolerance_mm) {
                            matches.push({
                                exp_index: expSpot.original_index, exp_x: expSpot.x, exp_y: expSpot.y,
                                sim_x: bestMatch.x_2d, sim_y: bestMatch.y_2d, error: minDist,
                                hkl: `(${bestMatch.h}, ${bestMatch.k}, ${bestMatch.l})`
                            });
                        } else {
                            matches.push({
                                exp_index: expSpot.original_index, exp_x: expSpot.x, exp_y: expSpot.y,
                                sim_x: null, sim_y: null, error: null, hkl: 'No match'
                            });
                        }
                    }
                    
                    doc.setFont(FONT.DATA, 'bold').setFontSize(SIZE.SMALL);
                    doc.text('Peak #', col1X, yPos);
                    doc.text('Exp U (mm)', col1X + 15, yPos);
                    doc.text('Exp V (mm)', col1X + 35, yPos);
                    doc.text('Sim U (mm)', col1X + 55, yPos);
                    doc.text('Sim V (mm)', col1X + 75, yPos);
                    doc.text('Error (mm)', col1X + 95, yPos);
                    doc.text('(h k l)', col1X + 115, yPos);
                    yPos += 5;
                    doc.setFont(FONT.DATA, 'normal').setFontSize(SIZE.SMALL);
                    
                    for (const match of matches) {
                        if (yPos > 280) { 
                            doc.addPage(); yPos = 20; 
                            doc.setFont(FONT.DATA, 'bold').setFontSize(SIZE.SMALL);
                            doc.text('Peak #', col1X, yPos); doc.text('Exp U (mm)', col1X + 15, yPos); doc.text('Exp V (mm)', col1X + 35, yPos);
                            doc.text('Sim U (mm)', col1X + 55, yPos); doc.text('Sim V (mm)', col1X + 75, yPos); doc.text('Error (mm)', col1X + 95, yPos);
                            doc.text('(h k l)', col1X + 115, yPos);
                            yPos += 5;
                            doc.setFont(FONT.DATA, 'normal').setFontSize(SIZE.SMALL);
                        }
                        doc.text(String(match.exp_index), col1X, yPos);
                        doc.text(match.exp_x.toFixed(3), col1X + 15, yPos);
                        doc.text(match.exp_y.toFixed(3), col1X + 35, yPos);
                        doc.text(match.sim_x !== null ? match.sim_x.toFixed(3) : 'N/A', col1X + 55, yPos);
                        doc.text(match.sim_y !== null ? match.sim_y.toFixed(3) : 'N/A', col1X + 75, yPos);
                        doc.text(match.error !== null ? match.error.toFixed(3) : 'N/A', col1X + 95, yPos);
                        doc.text(match.hkl, col1X + 115, yPos);
                        yPos += 4;
                    }
                  

                    yPos += 10; // Add space before the next section
                    
                    addHeader('Analysis Solutions Summary');
                    doc.setFont(FONT.LABEL, 'normal').setFontSize(SIZE.BODY);
                    doc.text("These are the calculated 'Base Orientations' relative to the goniometer's (0,0,0) home.", col1X, yPos);
                    yPos += 8;

                    doc.setFont(FONT.DATA, 'bold').setFontSize(SIZE.SMALL);
                    doc.text('Score', col1X, yPos);
                    doc.text('Matches', col1X + 25, yPos);
                    doc.text('RMS (mm)', col1X + 45, yPos);
                    doc.text('Rot X (°)', col1X + 70, yPos);
                    doc.text('Rot Y (°)', col1X + 90, yPos);
                    doc.text('Rot Z (°)', col1X + 110, yPos);
                    yPos += 5;
                    doc.setFont(FONT.DATA, 'normal').setFontSize(SIZE.SMALL);

                    orientationSolutions.slice(0, 20).forEach((sol, index) => {
                        if (yPos > 280) { 
                            doc.addPage(); yPos = 20; 
                            doc.setFont(FONT.DATA, 'bold').setFontSize(SIZE.SMALL);
                            doc.text('Score', col1X, yPos); doc.text('Matches', col1X + 25, yPos); doc.text('RMS (mm)', col1X + 45, yPos);
                            doc.text('Rot X (°)', col1X + 70, yPos); doc.text('Rot Y (°)', col1X + 90, yPos); doc.text('Rot Z (°)', col1X + 110, yPos);
                            yPos += 5;
                            doc.setFont(FONT.DATA, 'normal').setFontSize(SIZE.SMALL);
                        }
                        doc.text(sol.score.toFixed(4), col1X, yPos);
                        doc.text(`${sol.matches}/${experimentalSpots.length}`, col1X + 25, yPos);
                        doc.text(sol.rmsError.toFixed(3), col1X + 45, yPos);
                        doc.text(sol.euler.rotX.toFixed(2), col1X + 70, yPos);
                        doc.text(sol.euler.rotY.toFixed(2), col1X + 90, yPos);
                        doc.text(sol.euler.rotZ.toFixed(2), col1X + 110, yPos);
                        yPos += 4;
                    });
                }
                
                const pdfFileName = `Laue-Report-${now.getFullYear()}${String(now.getMonth() + 1).padStart(2, '0')}${String(now.getDate()).padStart(2, '0')}_${String(now.getHours()).padStart(2, '0')}${String(now.getMinutes()).padStart(2, '0')}.pdf`;
                doc.save(pdfFileName);
                statusInfoDiv.textContent = `Report saved as ${pdfFileName}`;

            } catch (error) {
                console.error("Failed to generate PDF:", error);
                statusInfoDiv.textContent = `Error generating PDF: ${error.message}`;
            } finally {
                reportButton.textContent = 'Generate Report';
                reportButton.disabled = false;
                document.body.style.cursor = 'default';
            }
        }


        function redrawDetector() {
    if (!detectorCtx) return;
    const w = detectorCanvas.width, h = detectorCanvas.height;
    detectorCtx.clearRect(0, 0, w, h);
    
    let centerX = w / 2;
    let centerY = h / 2;
    
    if (imageCenter) {
        centerX = imageCenter.canvas_x;
        centerY = imageCenter.canvas_y;
    }

    // Draw image center crosshair
    if (imageCenter) {
        detectorCtx.strokeStyle = '#00ff00';
        detectorCtx.lineWidth = 2;
        detectorCtx.beginPath();
        detectorCtx.moveTo(centerX - 10, centerY);
        detectorCtx.lineTo(centerX + 10, centerY);
        detectorCtx.moveTo(centerX, centerY - 10);
        detectorCtx.lineTo(centerX, centerY + 10);
        detectorCtx.stroke();
    }
    
    // Draw scale point crosshair
    if (scalePoint) {
        const crossSize = 15;
        const x = scalePoint.canvas_x;
        const y = scalePoint.canvas_y;
        detectorCtx.strokeStyle = '#00aaff'; 
        detectorCtx.lineWidth = 1.5; 
        detectorCtx.beginPath();
        detectorCtx.moveTo(x, y - crossSize);
        detectorCtx.lineTo(x, y + crossSize);
        detectorCtx.moveTo(x - crossSize, y);
        detectorCtx.lineTo(x + crossSize, y);
        detectorCtx.stroke();
        
        detectorCtx.strokeStyle = 'rgba(0, 170, 255, 0.5)';
        detectorCtx.lineWidth = 1;
        detectorCtx.beginPath();
        detectorCtx.moveTo(centerX, centerY);
        detectorCtx.lineTo(x, y);
        detectorCtx.stroke();
    }

    // Draw experimental spots
    if (experimentalSpots.length > 0) {
        detectorCtx.font = '12px Arial';
        detectorCtx.textAlign = 'center';
        detectorCtx.textBaseline = 'middle';
        experimentalSpots.forEach((spot, index) => {
            const canvas_x = spot.raw_x * imageTransform.scale + imageTransform.offsetX;
            const canvas_y = spot.raw_y * imageTransform.scale + imageTransform.offsetY;
            const isSelected = (index === selectedPeakIndex);
            detectorCtx.strokeStyle = isSelected ? '#44aaff' : '#00ff00';
            detectorCtx.lineWidth = isSelected ? 2.5 : 1.5;
            detectorCtx.beginPath();
            detectorCtx.arc(canvas_x, canvas_y, 7, 0, 2 * Math.PI);
            detectorCtx.stroke();
            detectorCtx.fillStyle = isSelected ? '#44aaff' : '#00ff00';
            detectorCtx.fillText(index + 1, canvas_x, canvas_y);
        });
    }
    
    // Determine pixel/mm scale
    const scale_valid = pixels_per_mm_x > 0 && pixels_per_mm_y > 0;
    let draw_scale_x, draw_scale_y;
    if (scale_valid) {
        draw_scale_x = pixels_per_mm_x; // U-scale
        draw_scale_y = pixels_per_mm_y; // V-scale
    } else {

        const default_mm_view_width = 100.0;
        const guess_scale = w / default_mm_view_width;
        draw_scale_x = guess_scale; 
        draw_scale_y = guess_scale;
    }


    // Draw simulated Laue spots
    if (document.getElementById('showSimulatedSpots').checked) {
        detectorSpots.forEach(spot => { 
            const isHighlighted = (highlightedSpot === spot); 
            let canvasX, canvasY;

            if (imageCenter) {
                const spot_raw_x = imageCenter.raw_x + (spot.x_2d * draw_scale_x); // u -> raw_x
                const spot_raw_y = imageCenter.raw_y - (spot.y_2d * draw_scale_y); // v -> raw_y
                canvasX = spot_raw_x * imageTransform.scale + imageTransform.offsetX;
                canvasY = spot_raw_y * imageTransform.scale + imageTransform.offsetY;
            } else {
                canvasX = centerX + spot.x_2d * draw_scale_x; 
                canvasY = centerY - spot.y_2d * draw_scale_y; 
            }
            
            if (canvasX < 0 || canvasX > w || canvasY < 0 || canvasY > h) return;
            
            let spotColor = isHighlighted ? '#ff4444' : '#ffff00'; 
            detectorCtx.beginPath();
            detectorCtx.arc(canvasX, canvasY, isHighlighted ? 6 : 2.5, 0, 2 * Math.PI);
            detectorCtx.fillStyle = spotColor;
            detectorCtx.fill(); 
            detectorCtx.strokeStyle = 'black';
            detectorCtx.lineWidth = 0.5;
            detectorCtx.stroke();
        });
    }

    // Draw scale bar
    const scaleBar_mm = 20;
    const avg_scale = (draw_scale_x + draw_scale_y) / 2.0;
    const scaleBar_px = scaleBar_mm * avg_scale;
    
    if (scaleBar_px > 10 && scaleBar_px < w * 0.8) {
        const y_pos = h - 30;
        const startX = (w / 2) - (scaleBar_px / 2);
        const endX = (w / 2) + (scaleBar_px / 2);
        
        detectorCtx.strokeStyle = '#ffffff';
        detectorCtx.fillStyle = '#ffffff';
        detectorCtx.lineWidth = 2;
        detectorCtx.font = '14px Arial';
        detectorCtx.textAlign = 'center';
        detectorCtx.beginPath();
        detectorCtx.moveTo(startX, y_pos);
        detectorCtx.lineTo(endX, y_pos);
        detectorCtx.moveTo(startX, y_pos - 5);
        detectorCtx.lineTo(startX, y_pos + 5);
        detectorCtx.moveTo(endX, y_pos - 5);
        detectorCtx.lineTo(endX, y_pos + 5);
        detectorCtx.stroke();
        
        detectorCtx.textBaseline = 'bottom'; 
        detectorCtx.fillText('2 cm', w / 2, y_pos - 8);
    }
}

    function identifyDetectorSpot(event, isClick) {
    if (detectorSpots.length === 0 || !document.getElementById('showSimulatedSpots').checked) return;

    const rect = detectorCanvas.getBoundingClientRect();
    const canvas_x = event.clientX - rect.left;
    const canvas_y = event.clientY - rect.top;
    
    // Determine scale - same logic as redrawDetector
    const scale_valid = pixels_per_mm_x > 0 && pixels_per_mm_y > 0;
    let draw_scale_x, draw_scale_y;
    if (scale_valid) {
        draw_scale_x = pixels_per_mm_x;
        draw_scale_y = pixels_per_mm_y;
    } else {

        const w = detectorCanvas.width;
        const default_mm_view_width = 100.0;
        const guess_scale = w / default_mm_view_width;
        draw_scale_x = guess_scale;
        draw_scale_y = guess_scale;
    }
    
    // Determine center position
    let centerX, centerY;
    if (imageCenter) {
        centerX = imageCenter.canvas_x;
        centerY = imageCenter.canvas_y;
    } else {
        centerX = detectorCanvas.width / 2;
        centerY = detectorCanvas.height / 2;
    }
    
    let closestSpot = null, minDistanceSq = Infinity;
    
    for (const spot of detectorSpots) {
        let spot_canvas_x, spot_canvas_y;
        
        if (imageCenter) {
            const spot_raw_x = imageCenter.raw_x + (spot.x_2d * draw_scale_x);
            const spot_raw_y = imageCenter.raw_y - (spot.y_2d * draw_scale_y);
            spot_canvas_x = spot_raw_x * imageTransform.scale + imageTransform.offsetX;
            spot_canvas_y = spot_raw_y * imageTransform.scale + imageTransform.offsetY;
        } else {
            spot_canvas_x = centerX + spot.x_2d * draw_scale_x;
            spot_canvas_y = centerY - spot.y_2d * draw_scale_y;
        }
        
        const distSq = (canvas_x - spot_canvas_x)**2 + (canvas_y - spot_canvas_y)**2;
        if (distSq < minDistanceSq) {
            minDistanceSq = distSq;
            closestSpot = spot;
        }
    }
    
    function gcd(a, b) { return b === 0 ? a : gcd(b, a % b); }
    function gcdOfThree(a, b, c) { return gcd(gcd(Math.abs(a), Math.abs(b)), Math.abs(c)); }
    
    if (closestSpot && minDistanceSq < 100) {
        const { h, k, l } = closestSpot;
        const commonDivisor = gcdOfThree(h, k, l);
        const h_r = (commonDivisor === 0) ? h : h / commonDivisor;
        const k_r = (commonDivisor === 0) ? k : k / commonDivisor;
        const l_r = (commonDivisor === 0) ? l : l / commonDivisor;
        const family = (commonDivisor > 1) ? ` (family of ${h},${k},${l})` : '';
        statusInfoDiv.textContent = `Spot (${h_r},${k_r},${l_r})${family}`;
        
        if (isClick || highlightedSpot !== closestSpot) {
            highlightedSpot = closestSpot;
            redrawDetector();
        }
    } else {
        if (isClick || highlightedSpot) {
            highlightedSpot = null;
            statusInfoDiv.textContent = 'Ready.';
            redrawDetector();
        }
    }
}


   // 
        /**
         * Draws a magnified view of the experimental image onto the zoom canvas.
         * @param {number} raw_x - The X coordinate on the *original* image to center on.
         * @param {number} raw_y - The Y coordinate on the *original* image to center on.
         */
        function updateZoomCanvas(raw_x, raw_y) {
            if (!experimentalImage || !zoomCtx) return;

            // Clear the zoom canvas
            zoomCtx.clearRect(0, 0, ZOOM_WINDOW_SIZE, ZOOM_WINDOW_SIZE);
            
            // Disable smoothing for a crisp, pixelated look
            zoomCtx.imageSmoothingEnabled = false;

            // Calculate the source rectangle (on the experimentalImage)
            const sourcePixelSize = ZOOM_WINDOW_SIZE / ZOOM_LEVEL;
            const sx = raw_x - sourcePixelSize / 2;
            const sy = raw_y - sourcePixelSize / 2;
            const sw = sourcePixelSize;
            const sh = sourcePixelSize;

            // Define the destination rectangle (the whole zoom canvas)
            const dx = 0;
            const dy = 0;
            const dw = ZOOM_WINDOW_SIZE;
            const dh = ZOOM_WINDOW_SIZE;

            // Draw the magnified image
            zoomCtx.drawImage(experimentalImage, sx, sy, sw, sh, dx, dy, dw, dh);

            // Draw crosshairs on the zoom canvas
            const mid = ZOOM_WINDOW_SIZE / 2;
            zoomCtx.strokeStyle = 'rgba(255, 0, 0, 0.7)';
            zoomCtx.lineWidth = 1;
            zoomCtx.beginPath();
            zoomCtx.moveTo(mid, 0);
            zoomCtx.lineTo(mid, ZOOM_WINDOW_SIZE);
            zoomCtx.moveTo(0, mid);
            zoomCtx.lineTo(ZOOM_WINDOW_SIZE, mid);
            zoomCtx.stroke();
        }



        // --- EVENT HANDLERS & SETUP ---
 
        function handleImageUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = function(e) {
                experimentalImage = new Image();
                experimentalImage.onload = function() {
                    // Reset analysis
                    imageCenter = null;
                    scalePoint = null;
                    pixels_per_mm_x = -1;
                    pixels_per_mm_y = -1;
                    experimentalSpots = [];
                    selectedPeakIndex = null;
                    orientationSolutions = [];
                    
                    baseOrientationMatrix.identity(); // Reset base orientation
                    document.getElementById('rotX').value = 0;
                    document.getElementById('rotY').value = 0;
                    document.getElementById('rotZ').value = 0;
                    document.getElementById('rotX_slider').value = 0;
                    document.getElementById('rotY_slider').value = 0;
                    document.getElementById('rotZ_slider').value = 0;
                    
                    document.getElementById('setCenterBtn').disabled = false;
                    document.getElementById('scaleControls').style.display = 'none';
                    document.getElementById('findPeaksBtn').disabled = true;
                    document.getElementById('searchOrientBtn').disabled = true;
                    
                    document.getElementById('invertContrast').checked = analyzeImageContrast();
                    updatePeakListUI();
                    updateSolutionsTab();
                    onWindowResize(); // This will also call redrawDetector
                    setUIMode('idle');
                    
                    // Call updateVisualization AFTER resetting sliders
                    updateVisualization(); 
                };
                experimentalImage.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }
        
        function analyzeImageContrast() {
            if (!experimentalImage) return false;
            const tempCanvas = document.createElement('canvas'); const tempCtx = tempCanvas.getContext('2d');
            const scale = 0.25; tempCanvas.width = experimentalImage.width * scale; tempCanvas.height = experimentalImage.height * scale;
            tempCtx.drawImage(experimentalImage, 0, 0, tempCanvas.width, tempCanvas.height);
            const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
            const data = imageData.data; const intensities = [];
            for (let i = 0; i < data.length; i += 4) { const intensity = 0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2]; intensities.push(intensity); }
            intensities.sort((a, b) => a - b);
            const mid = Math.floor(intensities.length / 2);
            const median = intensities.length % 2 !== 0 ? intensities[mid] : (intensities[mid - 1] + intensities[mid]) / 2;
            return median > 128;
        }

        function onDetectorWheel(e) {
            e.preventDefault();
            const distInput = document.getElementById('detectorDistance');
            const currentDist = parseFloat(distInput.value) - Math.sign(e.deltaY) * 2;
            distInput.value = Math.max(5, Math.min(200, currentDist)).toFixed(0);
            document.getElementById('detectorDistance_slider').value = distInput.value;
            updateVisualization();
        }
        
        function onDetectorMouseUp(e) {
            if (e.button === 0) {
                if (!isDragging && !isSettingCenter && !isAddingPeak && !isDraggingPeak && !isDraggingScalePoint) {
                    identifyDetectorSpot(e, true);
                }
              
              
                if (isDraggingScalePoint) {
                updateScale();
                zoomCanvas.style.display = 'none';
            }
            isPanning = false;


                isDragging = false;
                isDraggingPeak = false;
                isDraggingScalePoint = false;
                if (!isSettingCenter && !isAddingPeak) {
                    detectorContainer.style.cursor = 'default';
                }
            }
        }


        function onDetectorMouseMove(e) {
            const rect = detectorCanvas.getBoundingClientRect();
            const canvas_x = e.clientX - rect.left;
            const canvas_y = e.clientY - rect.top;

            // --- Calculate raw_x/raw_y early ---
            const raw_x = (canvas_x - imageTransform.offsetX) / imageTransform.scale;
            const raw_y = (canvas_y - imageTransform.offsetY) / imageTransform.scale;

            if ((isSettingCenter || isAddingPeak || isDraggingScalePoint) && experimentalImage) {                
                const offset = 25; // Pixel offset from cursor
                let zoomLeft, zoomTop;

                // Check X position
                if (canvas_x > detectorCanvas.width / 2) {
                    // Cursor is on the right half, open zoom to the left
                    zoomLeft = canvas_x - ZOOM_WINDOW_SIZE - offset;
                } else {
                    // Cursor is on the left half, open zoom to the right
                    zoomLeft = canvas_x + offset;
                }

                // Check Y position
                if (canvas_y > detectorCanvas.height / 2) {
                    // Cursor is on the bottom half, open zoom to the top
                    zoomTop = canvas_y - ZOOM_WINDOW_SIZE - offset;
                } else {
                    // Cursor is on the top half, open zoom to the bottom
                    zoomTop = canvas_y + offset;
                }
                
                // 1. Update zoom window position
                zoomCanvas.style.left = `${zoomLeft}px`;
                zoomCanvas.style.top = `${zoomTop}px`;
                // --- END NEW ---

                // 2. Update zoom window content
                updateZoomCanvas(raw_x, raw_y);
                
                // 3. Ensure zoom is visible (for dragging scale point)
                if (isDraggingScalePoint) {
                    zoomCanvas.style.display = 'block';
                }
            }

            if (isSettingCenter || isAddingPeak) {
                customCursor.style.left = 'none';
                customCursor.style.top = 'none';
                return;
            }
            
            if (isDraggingScalePoint) {
                scalePoint.canvas_x = canvas_x;
                scalePoint.canvas_y = canvas_y;
                scalePoint.raw_x = raw_x;
                scalePoint.raw_y = raw_y;
                
                const scale_valid = pixels_per_mm_x > 0 && pixels_per_mm_y > 0;
                if (imageCenter && scale_valid) { 
                     document.getElementById('scalePointX_mm').value = ((raw_x - imageCenter.raw_x) / pixels_per_mm_x).toFixed(2);
                     document.getElementById('scalePointY_mm').value = (-(raw_y - imageCenter.raw_y) / pixels_per_mm_y).toFixed(2);
                }
                updateScale();
                redrawDetector();
                return;
            }

            if (isDraggingPeak && selectedPeakIndex !== null) {
                experimentalSpots[selectedPeakIndex].raw_x = raw_x;
                experimentalSpots[selectedPeakIndex].raw_y = raw_y;
                updatePeakListUI();
                redrawDetector();
                return;
            }
            
            if (isPanning) {
                const cur = new THREE.Vector2(e.clientX, e.clientY);
                if (mouseDownPosition.distanceTo(cur) > 2) {
                    isDragging = true;
                    detectorContainer.style.cursor = 'grabbing';
                }
                if (isDragging) {
                    const dx = e.clientX - mouseDownPosition.x;
                    const dy = e.clientY - mouseDownPosition.y;
                    
                    // This now controls the Goniometer
                    let newRotZ = parseFloat(document.getElementById('rotZ').value) + dx * 0.25;
                    let newRotY = parseFloat(document.getElementById('rotY').value) + dy * 0.25;
                    newRotZ = Math.max(-90, Math.min(90, newRotZ));
                    newRotY = Math.max(-90, Math.min(90, newRotY));
                    
                    document.getElementById('rotZ').value = newRotZ.toFixed(0);
                    document.getElementById('rotY').value = newRotY.toFixed(0);
                    document.getElementById('rotZ_slider').value = newRotZ;
                    document.getElementById('rotY_slider').value = newRotY;
                    
                    mouseDownPosition.copy(cur);
                    updateVisualization(); // Update simulation with new goniometer angles
                }
            } else if (!isPanning) {
                identifyDetectorSpot(e, false);
            }
        }

        function onDetectorMouseDown(event) {
            if (event.button !== 0) return;
            
            const rect = detectorCanvas.getBoundingClientRect();
            const canvas_x = event.clientX - rect.left;
            const canvas_y = event.clientY - rect.top;
            const raw_x = (canvas_x - imageTransform.offsetX) / imageTransform.scale;
            const raw_y = (canvas_y - imageTransform.offsetY) / imageTransform.scale;

            if (isSettingCenter) {
                imageCenter = { canvas_x, canvas_y, raw_x, raw_y };
                const default_scale_canvas_x = rect.width - 50;
                const default_scale_canvas_y = 50;
                scalePoint = {
                    canvas_x: default_scale_canvas_x,
                    canvas_y: default_scale_canvas_y,
                    raw_x: (default_scale_canvas_x - imageTransform.offsetX) / imageTransform.scale,
                    raw_y: (default_scale_canvas_y - imageTransform.offsetY) / imageTransform.scale
                };
                document.getElementById('scaleControls').style.display = 'block';
                updateScale();
                redrawDetector();
                setUIMode('idle');
                return;
            }
            
            if (isAddingPeak) {
                experimentalSpots.push({ raw_x, raw_y });
                selectedPeakIndex = experimentalSpots.length - 1;
                updatePeakListUI();
                redrawDetector();
                setUIMode('idle');
                return;
            }

            if (scalePoint) {
                const distSq = (canvas_x - scalePoint.canvas_x)**2 + (canvas_y - scalePoint.canvas_y)**2;
                if (distSq < 100) {
                    isDraggingScalePoint = true;
                    return;
                }
            }
            
            let peakWasClicked = false;
            selectedPeakIndex = null;
            for (let i = experimentalSpots.length - 1; i >= 0; i--) {
                const spot = experimentalSpots[i];
                const spot_canvas_x = spot.raw_x * imageTransform.scale + imageTransform.offsetX;
                const spot_canvas_y = spot.raw_y * imageTransform.scale + imageTransform.offsetY;
                if (((canvas_x - spot_canvas_x)**2 + (canvas_y - spot_canvas_y)**2) < 100) {
                    selectedPeakIndex = i;
                    isDraggingPeak = true;
                    peakWasClicked = true;
                    break;
                }
            }
            
            if (!peakWasClicked && !isDraggingScalePoint) {
                isPanning = true;
                isDragging = false;
                mouseDownPosition.set(event.clientX, event.clientY);
            }
            updatePeakListUI();
            redrawDetector();
        }

        function onWindowResize() { 
            const cont = document.getElementById('detectorContainer'); 
            if (!cont) return; 
            const w = cont.clientWidth, h = cont.clientHeight; 
            if (w > 0 && h > 0) { 
                detectorCanvas.width = experimentCanvas.width = w; 
                detectorCanvas.height = experimentCanvas.height = h; 
            } 

            experimentCtx.clearRect(0, 0, w, h);
            
            if (experimentalImage) { 
                const imgAspect = experimentalImage.width / experimentalImage.height;
                const canvasAspect = w / h; 
                let drawW, drawH, dx, dy; 
                if (imgAspect > canvasAspect) { 
                    drawW = w; drawH = w / imgAspect; dx = 0; dy = (h - drawH) / 2; 
                } else { 
                    drawH = h; drawW = h * imgAspect; dy = 0; dx = (w - drawW) / 2; 
                } 
                experimentCtx.drawImage(experimentalImage, dx, dy, drawW, drawH); 
                imageTransform.scale = drawW / experimentalImage.width; 
                imageTransform.offsetX = dx; 
                imageTransform.offsetY = dy; 
            }
            
            if (experimentCanvas) {
                experimentCanvas.style.filter = document.getElementById('invertContrast').checked ? 'invert(1)' : 'none';
            }
            
            if (imageCenter) { 
                imageCenter.canvas_x = imageCenter.raw_x * imageTransform.scale + imageTransform.offsetX; 
                imageCenter.canvas_y = imageCenter.raw_y * imageTransform.scale + imageTransform.offsetY; 
            } 
            if (scalePoint) {
                scalePoint.canvas_x = scalePoint.raw_x * imageTransform.scale + imageTransform.offsetX;
                scalePoint.canvas_y = scalePoint.raw_y * imageTransform.scale + imageTransform.offsetY;
            }
            
            updateVisualization();
        }
        
        function initSliderLink(sliderId, numberId, callback) {
            const slider = document.getElementById(sliderId);
            const number = document.getElementById(numberId);
            if (slider && number) {
                slider.addEventListener('input', () => { number.value = slider.value; if(callback) callback(); });
                number.addEventListener('change', () => { slider.value = number.value; if(callback) callback(); }); 
            }
        }
        
        function init() {
            // Get DOM elements
            statusInfoDiv = document.getElementById('statusInfo');
            fomInfoDiv = document.getElementById('fomInfo');
            peakListEl = document.getElementById('peakList');
            solutionsListDiv = document.getElementById('solutionsList');
            orientStatusDiv = document.getElementById('orientStatus');
            detectorContainer = document.getElementById('detectorContainer');
            customCursor = document.getElementById('customCursor');
            detectorCanvas = document.getElementById('detectorCanvas');
            detectorCtx = detectorCanvas.getContext('2d');
            experimentCanvas = document.getElementById('experimentCanvas');
            experimentCtx = experimentCanvas.getContext('2d');
            
                     
            zoomCanvas = document.getElementById('zoomCanvas');
            zoomCtx = zoomCanvas.getContext('2d');
            
            zoomCanvas.width = ZOOM_WINDOW_SIZE;
            zoomCanvas.height = ZOOM_WINDOW_SIZE;
            zoomCanvas.style.width = `${ZOOM_WINDOW_SIZE}px`;
            zoomCanvas.style.height = `${ZOOM_WINDOW_SIZE}px`;
            baseOrientationMatrix.identity(); // Initialize as no rotation

            // Setup UI
            setupTabs();
            initLatticeDropdown();
            
            // Link sliders and number inputs
            initSliderLink('lambda_min_slider', 'lambda_min', updateVisualization);
            initSliderLink('lambda_max_slider', 'lambda_max', updateVisualization);
            initSliderLink('detectorAngle_slider', 'detectorAngle', updateVisualization); // <-- NEW
            initSliderLink('detectorDistance_slider', 'detectorDistance', updateVisualization);
            initSliderLink('rotX_slider', 'rotX', updateVisualization);
            initSliderLink('rotY_slider', 'rotY', updateVisualization);
            initSliderLink('rotZ_slider', 'rotZ', updateVisualization);
            
            // Link lattice param inputs
            document.querySelectorAll('#latticeParamsContainer input').forEach(el => {
                el.addEventListener('change', handleLatticeChange);
            });
            
            // Setup button listeners
            document.getElementById('imageLoader').addEventListener('change', handleImageUpload);
            document.getElementById('setCenterBtn').addEventListener('click', () => setUIMode('center'));
            document.getElementById('cancelModeBtn').addEventListener('click', () => setUIMode('idle'));
            document.getElementById('invertContrast').addEventListener('change', () => { 
                if (experimentalImage) onWindowResize(); 
            });
            document.getElementById('showSimulatedSpots').addEventListener('change', redrawDetector);
            
            document.getElementById('scalePointX_mm').addEventListener('input', updateScale);
            document.getElementById('scalePointY_mm').addEventListener('input', updateScale);
            
            document.getElementById('findPeaksBtn').addEventListener('click', detectPeaks);
            document.getElementById('addPeakBtn').addEventListener('click', () => setUIMode('add-peak'));
            
            document.getElementById('searchOrientBtn').addEventListener('click', findOrientation);
            document.getElementById('generateReportBtn').addEventListener('click', generateReport);
            document.getElementById('orientToHKLBtn').addEventListener('click', orientToHKL);

            // Setup canvas listeners
            detectorContainer.addEventListener('mousemove', e => {
                if (isSettingCenter || isAddingPeak) {
                    const rect = detectorContainer.getBoundingClientRect();
                    customCursor.style.left = `${e.clientX - rect.left}px`;
                    customCursor.style.top = `${e.clientY - rect.top}px`;
                }
            });
            detectorContainer.addEventListener('mouseenter', () => { if (isSettingCenter || isAddingPeak) customCursor.style.display = 'block'; });
            detectorContainer.addEventListener('mouseleave', () => { if (isSettingCenter || isAddingPeak) customCursor.style.display = 'none'; });
            
            detectorCanvas.addEventListener('contextmenu', e => e.preventDefault());
            detectorCanvas.addEventListener('wheel', onDetectorWheel, { passive: false });
            detectorCanvas.addEventListener('mousedown', onDetectorMouseDown);
            window.addEventListener('mousemove', onDetectorMouseMove);
            window.addEventListener('mouseup', onDetectorMouseUp);
            window.addEventListener('resize', onWindowResize);
            
            onWindowResize();
            setActiveTab('set');
            statusInfoDiv.textContent = 'Ready. Go to "Analysis" tab to load an image.';
        }
        
        window.addEventListener('load', init);
    </script>
</body>
</html>




